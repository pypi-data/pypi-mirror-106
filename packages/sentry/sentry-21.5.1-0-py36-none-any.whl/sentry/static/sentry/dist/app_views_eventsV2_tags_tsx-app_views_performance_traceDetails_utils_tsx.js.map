{"version":3,"sources":["webpack:///./app/components/events/interfaces/spans/utils.tsx","webpack:///./app/utils/performance/quickTrace/utils.tsx","webpack:///./app/views/eventsV2/tags.tsx","webpack:///./app/views/performance/traceDetails/utils.tsx"],"names":["TimestampStatus","normalizeTimestamps","spanBounds","startTimestamp","endTimestamp","boundsGenerator","bounds","viewStart","viewEnd","traceStartTimestamp","traceEndTimestamp","traceDuration","viewStartTimestamp","viewDuration","type","isSpanVisibleInView","timestampStatus","Stable","Equal","Reversed","parseSpanTimestamps","start","end","width","generateRootSpan","trace","trace_id","traceID","span_id","rootSpanID","parent_span_id","parentSpanID","start_timestamp","timestamp","op","description","data","status","rootSpanStatus","getTraceDateTimeRange","input","moment","subtract","utc","format","add","isGapSpan","span","isOrphanSpan","isOrphan","getSpanID","defaultSpanID","getSpanOperation","getSpanTraceID","getTraceContext","event","contexts","parseTrace","spanEntry","entries","find","entry","EntryType","spans","traceContext","rootSpanOpName","length","childSpans","numOfSpans","potentialParents","Set","map","init","reduced","reduce","acc","inputSpan","maybeSpanID","parentSpanId","getSpanParentSpanID","hasParent","has","isString","assert","spanChildren","push","set","hasEndTimestamp","isNumber","Object","values","forEach","sort","sortSpans","firstSpan","secondSpan","isOrphanTreeDepth","treeDepth","unwrapTreeDepth","depth","isEventFromBrowserJavaScriptSDK","sdkName","sdk","name","includes","toLowerCase","durationlessBrowserOps","hasFailedThreshold","marks","names","keys","WEB_VITAL_DETAILS","filter","vital","slug","some","record","value","poorThreshold","getMeasurements","measurements","Map","startsWith","slice","associatedMeasurement","undefined","mergedMeasurements","measurement","verticalMark","get","failedThreshold","getMeasurementBounds","generateBounds","warning","left","scrollToSpan","spanId","scrollToHash","location","e","preventDefault","hash","browserHistory","isTransaction","isCurrentEvent","currentEvent","event_id","id","errors","flattenRelevantPaths","traceFull","relevantPath","events","paths","path","current","shift","node","simplifyEvent","children","child","Error","omit","parseQuickTrace","quickTrace","organization","isFullTrace","parent","parent_event_id","root","generation","ancestors","descendants","projects","project_id","isChildren","isAncestor","isDescendant","size","trackAnalyticsEvent","eventKey","eventName","organization_id","parseInt","handleProjectMeta","sortTraceLite","a","b","beforeFetch","api","clear","getTraceRequestPayload","eventView","getEventsAPIPayload","makeEventView","statsPeriod","EventView","version","fields","ALL_ACCESS_PROJECTS","query","environment","range","getTraceTimeRangeFromEvent","dateReceived","dateCreated","valueOf","reduceTrace","visitor","initialValue","result","pop","filterTrace","predicate","transactions","transaction","isTraceFull","Boolean","isTraceFullDetailed","Tags","loading","tags","totalValues","error","prevProps","thisAPIPayload","props","getFacetsAPIPayload","otherAPIPayload","isAPIPayloadSimilar","forceFetchData","confirmedQuery","setState","fetchTagFacets","Sentry","tag","state","renderPlaceholders","height","color","renderTag","StyledEmptyStateWarning","small","t","this","fetchData","shouldRefetchData","generateUrl","segments","topValues","segment","url","key","maxTotalValues","Math","max","Number","count","title","renderLoading","StyledPlaceholder","onTagClick","handleTagClick","showReleasePackage","Fragment","StyledPlaceholderTitle","renderBody","Component","EmptyStateWarning","Placeholder","p","theme","borderRadius","space","withApi","getTraceDetailsUrl","traceSlug","dateSelection","pathname","PAGE_URL_PARAM","getTraceInfo","traces","initial","MAX_SAFE_INTEGER","maxGeneration","info","accumulator","project_slug","min","isRootTransaction"],"mappings":"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","file":"app_views_eventsV2_tags_tsx-app_views_performance_traceDetails_utils_tsx.aecb69aad1fdf1ca8bdc.js","sourcesContent":["import {MouseEvent} from 'react';\nimport {browserHistory} from 'react-router';\nimport {Location} from 'history';\nimport isNumber from 'lodash/isNumber';\nimport isString from 'lodash/isString';\nimport set from 'lodash/set';\nimport moment from 'moment';\n\nimport {EntryType, EventTransaction} from 'app/types/event';\nimport {assert} from 'app/types/utils';\nimport {WEB_VITAL_DETAILS} from 'app/utils/performance/vitals/constants';\n\nimport {\n  GapSpanType,\n  OrphanSpanType,\n  OrphanTreeDepth,\n  ParsedTraceType,\n  ProcessedSpanType,\n  RawSpanType,\n  SpanEntry,\n  SpanType,\n  TraceContextType,\n  TreeDepthType,\n} from './types';\n\nexport const isValidSpanID = (maybeSpanID: any) =>\n  isString(maybeSpanID) && maybeSpanID.length > 0;\n\nexport type SpanBoundsType = {startTimestamp: number; endTimestamp: number};\nexport type SpanGeneratedBoundsType =\n  | {type: 'TRACE_TIMESTAMPS_EQUAL'; isSpanVisibleInView: boolean}\n  | {type: 'INVALID_VIEW_WINDOW'; isSpanVisibleInView: boolean}\n  | {\n      type: 'TIMESTAMPS_EQUAL';\n      start: number;\n      width: number;\n      isSpanVisibleInView: boolean;\n    }\n  | {\n      type: 'TIMESTAMPS_REVERSED';\n      start: number;\n      end: number;\n      isSpanVisibleInView: boolean;\n    }\n  | {\n      type: 'TIMESTAMPS_STABLE';\n      start: number;\n      end: number;\n      isSpanVisibleInView: boolean;\n    };\n\nexport type SpanViewBoundsType = {\n  warning: undefined | string;\n  left: undefined | number;\n  width: undefined | number;\n  isSpanVisibleInView: boolean;\n};\n\nconst normalizeTimestamps = (spanBounds: SpanBoundsType): SpanBoundsType => {\n  const {startTimestamp, endTimestamp} = spanBounds;\n\n  if (startTimestamp > endTimestamp) {\n    return {startTimestamp: endTimestamp, endTimestamp: startTimestamp};\n  }\n\n  return spanBounds;\n};\n\nexport enum TimestampStatus {\n  Stable,\n  Reversed,\n  Equal,\n}\n\nexport const parseSpanTimestamps = (spanBounds: SpanBoundsType): TimestampStatus => {\n  const startTimestamp: number = spanBounds.startTimestamp;\n  const endTimestamp: number = spanBounds.endTimestamp;\n\n  if (startTimestamp < endTimestamp) {\n    return TimestampStatus.Stable;\n  }\n\n  if (startTimestamp === endTimestamp) {\n    return TimestampStatus.Equal;\n  }\n\n  return TimestampStatus.Reversed;\n};\n\n// given the start and end trace timestamps, and the view window, we want to generate a function\n// that'll output the relative %'s for the width and placements relative to the left-hand side.\n//\n// The view window (viewStart and viewEnd) are percentage values (between 0% and 100%), they correspond to the window placement\n// between the start and end trace timestamps.\nexport const boundsGenerator = (bounds: {\n  traceStartTimestamp: number; // unix timestamp\n  traceEndTimestamp: number; // unix timestamp\n  viewStart: number; // in [0, 1]\n  viewEnd: number; // in [0, 1]\n}) => {\n  const {viewStart, viewEnd} = bounds;\n\n  const {\n    startTimestamp: traceStartTimestamp,\n    endTimestamp: traceEndTimestamp,\n  } = normalizeTimestamps({\n    startTimestamp: bounds.traceStartTimestamp,\n    endTimestamp: bounds.traceEndTimestamp,\n  });\n\n  // viewStart and viewEnd are percentage values (%) of the view window relative to the left\n  // side of the trace view minimap\n\n  // invariant: viewStart <= viewEnd\n\n  // duration of the entire trace in seconds\n  const traceDuration = traceEndTimestamp - traceStartTimestamp;\n\n  const viewStartTimestamp = traceStartTimestamp + viewStart * traceDuration;\n  const viewEndTimestamp = traceEndTimestamp - (1 - viewEnd) * traceDuration;\n  const viewDuration = viewEndTimestamp - viewStartTimestamp;\n\n  return (spanBounds: SpanBoundsType): SpanGeneratedBoundsType => {\n    // TODO: alberto.... refactor so this is impossible ðŸ˜ \n    if (traceDuration <= 0) {\n      return {\n        type: 'TRACE_TIMESTAMPS_EQUAL',\n        isSpanVisibleInView: true,\n      };\n    }\n\n    if (viewDuration <= 0) {\n      return {\n        type: 'INVALID_VIEW_WINDOW',\n        isSpanVisibleInView: true,\n      };\n    }\n\n    const {startTimestamp, endTimestamp} = normalizeTimestamps(spanBounds);\n\n    const timestampStatus = parseSpanTimestamps(spanBounds);\n\n    const start = (startTimestamp - viewStartTimestamp) / viewDuration;\n    const end = (endTimestamp - viewStartTimestamp) / viewDuration;\n\n    const isSpanVisibleInView = end > 0 && start < 1;\n\n    switch (timestampStatus) {\n      case TimestampStatus.Equal: {\n        return {\n          type: 'TIMESTAMPS_EQUAL',\n          start,\n          width: 1,\n          // a span bar is visible even if they're at the extreme ends of the view selection.\n          // these edge cases are:\n          // start == end == 0, and\n          // start == end == 1\n          isSpanVisibleInView: end >= 0 && start <= 1,\n        };\n      }\n      case TimestampStatus.Reversed: {\n        return {\n          type: 'TIMESTAMPS_REVERSED',\n          start,\n          end,\n          isSpanVisibleInView,\n        };\n      }\n      case TimestampStatus.Stable: {\n        return {\n          type: 'TIMESTAMPS_STABLE',\n          start,\n          end,\n          isSpanVisibleInView,\n        };\n      }\n      default: {\n        const _exhaustiveCheck: never = timestampStatus;\n        return _exhaustiveCheck;\n      }\n    }\n  };\n};\n\nexport function generateRootSpan(trace: ParsedTraceType): RawSpanType {\n  const rootSpan: RawSpanType = {\n    trace_id: trace.traceID,\n    span_id: trace.rootSpanID,\n    parent_span_id: trace.parentSpanID,\n    start_timestamp: trace.traceStartTimestamp,\n    timestamp: trace.traceEndTimestamp,\n    op: trace.op,\n    description: trace.description,\n    data: {},\n    status: trace.rootSpanStatus,\n  };\n\n  return rootSpan;\n}\n\n// start and end are assumed to be unix timestamps with fractional seconds\nexport function getTraceDateTimeRange(input: {\n  start: number;\n  end: number;\n}): {start: string; end: string} {\n  const start = moment\n    .unix(input.start)\n    .subtract(12, 'hours')\n    .utc()\n    .format('YYYY-MM-DDTHH:mm:ss.SSS');\n\n  const end = moment\n    .unix(input.end)\n    .add(12, 'hours')\n    .utc()\n    .format('YYYY-MM-DDTHH:mm:ss.SSS');\n\n  return {\n    start,\n    end,\n  };\n}\n\nexport function isGapSpan(span: ProcessedSpanType): span is GapSpanType {\n  if ('type' in span) {\n    return span.type === 'gap';\n  }\n\n  return false;\n}\n\nexport function isOrphanSpan(span: ProcessedSpanType): span is OrphanSpanType {\n  if ('type' in span) {\n    if (span.type === 'orphan') {\n      return true;\n    }\n\n    if (span.type === 'gap') {\n      return span.isOrphan;\n    }\n  }\n\n  return false;\n}\n\nexport function getSpanID(span: ProcessedSpanType, defaultSpanID: string = ''): string {\n  if (isGapSpan(span)) {\n    return defaultSpanID;\n  }\n\n  return span.span_id;\n}\n\nexport function getSpanOperation(span: ProcessedSpanType): string | undefined {\n  if (isGapSpan(span)) {\n    return undefined;\n  }\n\n  return span.op;\n}\n\nexport function getSpanTraceID(span: ProcessedSpanType): string {\n  if (isGapSpan(span)) {\n    return 'gap-span';\n  }\n\n  return span.trace_id;\n}\n\nexport function getSpanParentSpanID(span: ProcessedSpanType): string | undefined {\n  if (isGapSpan(span)) {\n    return 'gap-span';\n  }\n\n  return span.parent_span_id;\n}\n\nexport function getTraceContext(\n  event: Readonly<EventTransaction>\n): TraceContextType | undefined {\n  return event?.contexts?.trace;\n}\n\nexport function parseTrace(event: Readonly<EventTransaction>): ParsedTraceType {\n  const spanEntry = event.entries.find((entry: SpanEntry | any): entry is SpanEntry => {\n    return entry.type === EntryType.SPANS;\n  });\n\n  const spans: Array<RawSpanType> = spanEntry?.data ?? [];\n\n  const traceContext = getTraceContext(event);\n  const traceID = (traceContext && traceContext.trace_id) || '';\n  const rootSpanID = (traceContext && traceContext.span_id) || '';\n  const rootSpanOpName = (traceContext && traceContext.op) || 'transaction';\n  const description = traceContext && traceContext.description;\n  const parentSpanID = traceContext && traceContext.parent_span_id;\n  const rootSpanStatus = traceContext && traceContext.status;\n\n  if (!spanEntry || spans.length <= 0) {\n    return {\n      op: rootSpanOpName,\n      childSpans: {},\n      traceStartTimestamp: event.startTimestamp,\n      traceEndTimestamp: event.endTimestamp,\n      traceID,\n      rootSpanID,\n      rootSpanStatus,\n      parentSpanID,\n      numOfSpans: 0,\n      spans: [],\n      description,\n    };\n  }\n\n  // any span may be a parent of another span\n  const potentialParents = new Set(\n    spans.map(span => {\n      return span.span_id;\n    })\n  );\n\n  // the root transaction span is a parent of all other spans\n  potentialParents.add(rootSpanID);\n\n  // we reduce spans to become an object mapping span ids to their children\n\n  const init: ParsedTraceType = {\n    op: rootSpanOpName,\n    childSpans: {},\n    traceStartTimestamp: event.startTimestamp,\n    traceEndTimestamp: event.endTimestamp,\n    traceID,\n    rootSpanID,\n    rootSpanStatus,\n    parentSpanID,\n    numOfSpans: spans.length,\n    spans,\n    description,\n  };\n\n  const reduced: ParsedTraceType = spans.reduce((acc, inputSpan) => {\n    let span: SpanType = inputSpan;\n\n    const parentSpanId = getSpanParentSpanID(span);\n\n    const hasParent = parentSpanId && potentialParents.has(parentSpanId);\n\n    if (!isValidSpanID(parentSpanId) || !hasParent) {\n      // this span is considered an orphan with respect to the spans within this transaction.\n      // although the span is an orphan, it's still a descendant of this transaction,\n      // so we set its parent span id to be the root transaction span's id\n      span.parent_span_id = rootSpanID;\n\n      span = {\n        type: 'orphan',\n        ...span,\n      } as OrphanSpanType;\n    }\n\n    assert(span.parent_span_id);\n\n    // get any span children whose parent_span_id is equal to span.parent_span_id,\n    // otherwise start with an empty array\n    const spanChildren: Array<SpanType> = acc.childSpans[span.parent_span_id] ?? [];\n\n    spanChildren.push(span);\n\n    set(acc.childSpans, span.parent_span_id, spanChildren);\n\n    // set trace start & end timestamps based on given span's start and end timestamps\n\n    if (!acc.traceStartTimestamp || span.start_timestamp < acc.traceStartTimestamp) {\n      acc.traceStartTimestamp = span.start_timestamp;\n    }\n\n    // establish trace end timestamp\n\n    const hasEndTimestamp = isNumber(span.timestamp);\n\n    if (!acc.traceEndTimestamp) {\n      if (hasEndTimestamp) {\n        acc.traceEndTimestamp = span.timestamp;\n        return acc;\n      }\n\n      acc.traceEndTimestamp = span.start_timestamp;\n      return acc;\n    }\n\n    if (hasEndTimestamp && span.timestamp! > acc.traceEndTimestamp) {\n      acc.traceEndTimestamp = span.timestamp;\n      return acc;\n    }\n\n    if (span.start_timestamp > acc.traceEndTimestamp) {\n      acc.traceEndTimestamp = span.start_timestamp;\n    }\n\n    return acc;\n  }, init);\n\n  // sort span children\n\n  Object.values(reduced.childSpans).forEach(spanChildren => {\n    spanChildren.sort(sortSpans);\n  });\n\n  return reduced;\n}\n\nfunction sortSpans(firstSpan: SpanType, secondSpan: SpanType) {\n  // orphan spans come after non-orphan spans.\n\n  if (isOrphanSpan(firstSpan) && !isOrphanSpan(secondSpan)) {\n    // sort secondSpan before firstSpan\n    return 1;\n  }\n\n  if (!isOrphanSpan(firstSpan) && isOrphanSpan(secondSpan)) {\n    // sort firstSpan before secondSpan\n    return -1;\n  }\n\n  // sort spans by their start timestamp in ascending order\n\n  if (firstSpan.start_timestamp < secondSpan.start_timestamp) {\n    // sort firstSpan before secondSpan\n    return -1;\n  }\n\n  if (firstSpan.start_timestamp === secondSpan.start_timestamp) {\n    return 0;\n  }\n\n  // sort secondSpan before firstSpan\n  return 1;\n}\n\nexport function isOrphanTreeDepth(\n  treeDepth: TreeDepthType\n): treeDepth is OrphanTreeDepth {\n  if (typeof treeDepth === 'number') {\n    return false;\n  }\n  return treeDepth?.type === 'orphan';\n}\n\nexport function unwrapTreeDepth(treeDepth: TreeDepthType): number {\n  if (isOrphanTreeDepth(treeDepth)) {\n    return treeDepth.depth;\n  }\n\n  return treeDepth;\n}\n\nexport function isEventFromBrowserJavaScriptSDK(event: EventTransaction): boolean {\n  const sdkName = event.sdk?.name;\n  if (!sdkName) {\n    return false;\n  }\n  // based on https://github.com/getsentry/sentry-javascript/blob/master/packages/browser/src/version.ts\n  return [\n    'sentry.javascript.browser',\n    'sentry.javascript.react',\n    'sentry.javascript.gatsby',\n    'sentry.javascript.ember',\n    'sentry.javascript.vue',\n    'sentry.javascript.angular',\n    'sentry.javascript.nextjs',\n  ].includes(sdkName.toLowerCase());\n}\n\n// Durationless ops from: https://github.com/getsentry/sentry-javascript/blob/0defcdcc2dfe719343efc359d58c3f90743da2cd/packages/apm/src/integrations/tracing.ts#L629-L688\n// PerformanceMark: Duration is 0 as per https://developer.mozilla.org/en-US/docs/Web/API/PerformanceMark\n// PerformancePaintTiming: Duration is 0 as per https://developer.mozilla.org/en-US/docs/Web/API/PerformancePaintTiming\nexport const durationlessBrowserOps = ['mark', 'paint'];\n\ntype Measurements = {\n  [name: string]: number | undefined;\n};\n\ntype VerticalMark = {\n  marks: Measurements;\n  failedThreshold: boolean;\n};\n\nfunction hasFailedThreshold(marks: Measurements): boolean {\n  const names = Object.keys(marks);\n  const records = Object.values(WEB_VITAL_DETAILS).filter(vital =>\n    names.includes(vital.slug)\n  );\n\n  return records.some(record => {\n    const value = marks[record.slug];\n    if (typeof value === 'number') {\n      return value >= record.poorThreshold;\n    }\n    return false;\n  });\n}\n\nexport function getMeasurements(event: EventTransaction): Map<number, VerticalMark> {\n  if (!event.measurements) {\n    return new Map();\n  }\n\n  const measurements = Object.keys(event.measurements)\n    .filter(name => name.startsWith('mark.'))\n    .map(name => {\n      const slug = name.slice('mark.'.length);\n      const associatedMeasurement = event.measurements![slug];\n      return {\n        name,\n        timestamp: event.measurements![name].value,\n        value: associatedMeasurement ? associatedMeasurement.value : undefined,\n      };\n    });\n\n  const mergedMeasurements = new Map<number, VerticalMark>();\n\n  measurements.forEach(measurement => {\n    const name = measurement.name.slice('mark.'.length);\n    const value = measurement.value;\n\n    if (mergedMeasurements.has(measurement.timestamp)) {\n      const verticalMark = mergedMeasurements.get(measurement.timestamp) as VerticalMark;\n\n      verticalMark.marks = {\n        ...verticalMark.marks,\n        [name]: value,\n      };\n\n      if (!verticalMark.failedThreshold) {\n        verticalMark.failedThreshold = hasFailedThreshold(verticalMark.marks);\n      }\n\n      mergedMeasurements.set(measurement.timestamp, verticalMark);\n      return;\n    }\n\n    const marks = {\n      [name]: value,\n    };\n\n    mergedMeasurements.set(measurement.timestamp, {\n      marks,\n      failedThreshold: hasFailedThreshold(marks),\n    });\n  });\n\n  return mergedMeasurements;\n}\n\nexport function getMeasurementBounds(\n  timestamp: number,\n  generateBounds: (bounds: SpanBoundsType) => SpanGeneratedBoundsType\n): SpanViewBoundsType {\n  const bounds = generateBounds({\n    startTimestamp: timestamp,\n    endTimestamp: timestamp,\n  });\n\n  switch (bounds.type) {\n    case 'TRACE_TIMESTAMPS_EQUAL':\n    case 'INVALID_VIEW_WINDOW': {\n      return {\n        warning: undefined,\n        left: undefined,\n        width: undefined,\n        isSpanVisibleInView: bounds.isSpanVisibleInView,\n      };\n    }\n    case 'TIMESTAMPS_EQUAL': {\n      return {\n        warning: undefined,\n        left: bounds.start,\n        width: 0.00001,\n        isSpanVisibleInView: bounds.isSpanVisibleInView,\n      };\n    }\n    case 'TIMESTAMPS_REVERSED': {\n      return {\n        warning: undefined,\n        left: bounds.start,\n        width: bounds.end - bounds.start,\n        isSpanVisibleInView: bounds.isSpanVisibleInView,\n      };\n    }\n    case 'TIMESTAMPS_STABLE': {\n      return {\n        warning: void 0,\n        left: bounds.start,\n        width: bounds.end - bounds.start,\n        isSpanVisibleInView: bounds.isSpanVisibleInView,\n      };\n    }\n    default: {\n      const _exhaustiveCheck: never = bounds;\n      return _exhaustiveCheck;\n    }\n  }\n}\n\nexport function scrollToSpan(\n  spanId: string,\n  scrollToHash: (hash: string) => void,\n  location: Location\n) {\n  return (e: MouseEvent<Element>) => {\n    // do not use the default anchor behaviour\n    // because it will be hidden behind the minimap\n    e.preventDefault();\n\n    const hash = `#span-${spanId}`;\n\n    scrollToHash(hash);\n\n    // TODO(txiao): This is causing a rerender of the whole page,\n    // which can be slow.\n    //\n    // make sure to update the location\n    browserHistory.push({\n      ...location,\n      hash,\n    });\n  };\n}\n","import omit from 'lodash/omit';\nimport moment from 'moment-timezone';\n\nimport {Client} from 'app/api';\nimport {getTraceDateTimeRange} from 'app/components/events/interfaces/spans/utils';\nimport {ALL_ACCESS_PROJECTS} from 'app/constants/globalSelectionHeader';\nimport {OrganizationSummary} from 'app/types';\nimport {Event, EventTransaction} from 'app/types/event';\nimport {trackAnalyticsEvent} from 'app/utils/analytics';\nimport EventView from 'app/utils/discover/eventView';\nimport {DiscoverQueryProps} from 'app/utils/discover/genericDiscoverQuery';\nimport {\n  QuickTrace,\n  QuickTraceEvent,\n  TraceFull,\n  TraceFullDetailed,\n  TraceLite,\n} from 'app/utils/performance/quickTrace/types';\n\nexport function isTransaction(event: Event): event is EventTransaction {\n  return event.type === 'transaction';\n}\n\n/**\n * An event can be an error or a transaction. We need to check whether the current\n * event id is in the list of errors as well\n */\nexport function isCurrentEvent(\n  event: TraceFull | QuickTraceEvent,\n  currentEvent: Event\n): boolean {\n  if (isTransaction(currentEvent)) {\n    return event.event_id === currentEvent.id;\n  } else {\n    return (\n      event.errors !== undefined && event.errors.some(e => e.event_id === currentEvent.id)\n    );\n  }\n}\n\ntype PathNode = {\n  event: TraceFull;\n  path: TraceLite;\n};\n\n/**\n * The `events-full` endpoint returns the full trace containing the specified event.\n * This means any sibling paths in the trace will also be returned.\n *\n * This method strips away these sibling paths leaving only the path from the root to\n * the specified event and all of its children/descendants.\n *\n * This method additionally flattens the trace into an array of the transactions in\n * the trace.\n */\nexport function flattenRelevantPaths(\n  currentEvent: Event,\n  traceFull: TraceFull\n): TraceLite {\n  const relevantPath: TraceLite = [];\n  const events: TraceFull[] = [];\n\n  /**\n   * First find a path from the root transaction to the current transaction via\n   * a breadth first search. This adds all transactions from the root to the\n   * current transaction (excluding the current transaction itself), to the\n   * relevant path.\n   */\n  const paths: PathNode[] = [{event: traceFull, path: []}];\n  while (paths.length) {\n    const current = paths.shift()!;\n    if (isCurrentEvent(current.event, currentEvent)) {\n      for (const node of current.path) {\n        relevantPath.push(node);\n      }\n      events.push(current.event);\n    } else {\n      const path = [...current.path, simplifyEvent(current.event)];\n      for (const child of current.event.children) {\n        paths.push({event: child, path});\n      }\n    }\n  }\n\n  if (!events.length) {\n    throw new Error('No relevant path exists!');\n  }\n\n  /**\n   * Traverse all transactions from current transaction onwards and add\n   * them all to the relevant path.\n   */\n  while (events.length) {\n    const current = events.shift()!;\n    for (const child of current.children) {\n      events.push(child);\n    }\n    relevantPath.push(simplifyEvent(current));\n  }\n\n  return relevantPath;\n}\n\nfunction simplifyEvent(event: TraceFull): QuickTraceEvent {\n  return omit(event, ['children']);\n}\n\ntype ParsedQuickTrace = {\n  /**\n   * `null` represents the lack of a root. It may still have a parent\n   */\n  root: QuickTraceEvent | null;\n  /**\n   * `[]` represents the lack of ancestors in a full quick trace\n   * `null` represents the uncertainty of ancestors in a lite quick trace\n   */\n  ancestors: QuickTraceEvent[] | null;\n  /**\n   * `null` represents either the lack of a direct parent or the uncertainty\n   * of what the parent is\n   */\n  parent: QuickTraceEvent | null;\n  current: QuickTraceEvent;\n  /**\n   * `[]` represents the lack of children in a full/lite quick trace\n   */\n  children: QuickTraceEvent[];\n  /**\n   * `[]` represents the lack of descendants in a full quick trace\n   * `null` represents the uncertainty of descendants in a lite quick trace\n   */\n  descendants: QuickTraceEvent[] | null;\n};\n\nexport function parseQuickTrace(\n  quickTrace: QuickTrace,\n  event: Event,\n  organization: OrganizationSummary\n): ParsedQuickTrace | null {\n  const {type, trace} = quickTrace;\n\n  if (type === 'empty' || trace === null) {\n    throw new Error('Current event not in quick trace!');\n  }\n\n  const isFullTrace = type === 'full';\n\n  const current = trace.find(e => isCurrentEvent(e, event)) ?? null;\n  if (current === null) {\n    throw new Error('Current event not in quick trace!');\n  }\n\n  /**\n   * The parent event is the direct ancestor of the current event.\n   * This takes priority over the root, meaning if the parent is\n   * the root of the trace, this favours showing it as the parent.\n   */\n  const parent = current.parent_event_id\n    ? trace.find(e => e.event_id === current.parent_event_id) ?? null\n    : null;\n\n  /**\n   * The root event is the first event in the trace. This has lower priority\n   * than the parent event, meaning if the root event is the parent event of\n   * the current event, this favours showing it as the parent event.\n   */\n  const root =\n    trace.find(\n      e =>\n        // a root can't be the current event\n        e.event_id !== current.event_id &&\n        // a root can't be the direct parent\n        e.event_id !== parent?.event_id &&\n        // a root has to to be the first generation\n        e.generation === 0\n    ) ?? null;\n\n  const isChildren = e => e.parent_event_id === current.event_id;\n\n  const isDescendant = e =>\n    // the current generation needs to be known to determine a descendant\n    current.generation !== null &&\n    // the event's generation needs to be known to determine a descendant\n    e.generation !== null &&\n    // a descendant is the generation after the direct children\n    current.generation + 1 < e.generation;\n\n  const isAncestor = e =>\n    // the current generation needs to be known to determine an ancestor\n    current.generation !== null &&\n    // the event's generation needs to be known to determine an ancestor\n    e.generation !== null &&\n    // an ancestor cant be the root\n    e.generation > 0 &&\n    // an ancestor is the generation before the direct parent\n    current.generation - 1 > e.generation;\n\n  const ancestors: TraceLite | null = isFullTrace ? [] : null;\n  const children: TraceLite = [];\n  const descendants: TraceLite | null = isFullTrace ? [] : null;\n  const projects = new Set();\n\n  trace.forEach(e => {\n    projects.add(e.project_id);\n    if (isChildren(e)) {\n      children.push(e);\n    } else if (isFullTrace) {\n      if (isAncestor(e)) {\n        ancestors?.push(e);\n      } else if (isDescendant(e)) {\n        descendants?.push(e);\n      }\n    }\n  });\n\n  if (isFullTrace && projects.size > 1) {\n    handleProjectMeta(organization, projects.size);\n  }\n\n  return {\n    root,\n    ancestors: ancestors === null ? null : sortTraceLite(ancestors),\n    parent,\n    current,\n    children: sortTraceLite(children),\n    descendants: descendants === null ? null : sortTraceLite(descendants),\n  };\n}\n\nfunction sortTraceLite(trace: TraceLite): TraceLite {\n  return trace.sort((a, b) => b['transaction.duration'] - a['transaction.duration']);\n}\n\nexport function beforeFetch(api: Client) {\n  api.clear();\n}\n\nexport function getTraceRequestPayload({eventView, location}: DiscoverQueryProps) {\n  return omit(eventView.getEventsAPIPayload(location), ['field', 'sort', 'per_page']);\n}\n\nexport function makeEventView({\n  start,\n  end,\n  statsPeriod,\n}: {\n  start?: string;\n  end?: string;\n  statsPeriod?: string;\n}) {\n  return EventView.fromSavedQuery({\n    id: undefined,\n    version: 2,\n    name: '',\n    // This field doesn't actually do anything,\n    // just here to satify a constraint in EventView.\n    fields: ['transaction.duration'],\n    projects: [ALL_ACCESS_PROJECTS],\n    query: '',\n    environment: [],\n    start,\n    end,\n    range: statsPeriod,\n  });\n}\n\nexport function getTraceTimeRangeFromEvent(event: Event): {start: string; end: string} {\n  const start = isTransaction(event)\n    ? event.startTimestamp\n    : moment(event.dateReceived ? event.dateReceived : event.dateCreated).valueOf() /\n      1000;\n  const end = isTransaction(event) ? event.endTimestamp : start;\n  return getTraceDateTimeRange({start, end});\n}\n\nexport function reduceTrace<T>(\n  trace: TraceFullDetailed,\n  visitor: (acc: T, e: TraceFullDetailed) => T,\n  initialValue: T\n): T {\n  let result = initialValue;\n\n  const events = [trace];\n  while (events.length) {\n    const current = events.pop()!;\n    for (const child of current.children) {\n      events.push(child);\n    }\n    result = visitor(result, current);\n  }\n\n  return result;\n}\n\nexport function filterTrace(\n  trace: TraceFullDetailed,\n  predicate: (transaction: TraceFullDetailed) => boolean\n): TraceFullDetailed[] {\n  return reduceTrace<TraceFullDetailed[]>(\n    trace,\n    (transactions, transaction) => {\n      if (predicate(transaction)) {\n        transactions.push(transaction);\n      }\n      return transactions;\n    },\n    []\n  );\n}\n\nexport function isTraceFull(transaction): transaction is TraceFull {\n  return Boolean((transaction as TraceFull).event_id);\n}\n\nexport function isTraceFullDetailed(transaction): transaction is TraceFullDetailed {\n  return Boolean((transaction as TraceFullDetailed).event_id);\n}\n\nfunction handleProjectMeta(organization: OrganizationSummary, projects: number) {\n  trackAnalyticsEvent({\n    eventKey: 'quick_trace.connected_services',\n    eventName: 'Quick Trace: Connected Services',\n    organization_id: parseInt(organization.id, 10),\n    projects,\n  });\n}\n","import {Component, Fragment} from 'react';\nimport styled from '@emotion/styled';\nimport * as Sentry from '@sentry/react';\nimport {Location, LocationDescriptor} from 'history';\n\nimport {fetchTagFacets, Tag, TagSegment} from 'app/actionCreators/events';\nimport {Client} from 'app/api';\nimport ErrorPanel from 'app/components/charts/errorPanel';\nimport {SectionHeading} from 'app/components/charts/styles';\nimport EmptyStateWarning from 'app/components/emptyStateWarning';\nimport Placeholder from 'app/components/placeholder';\nimport TagDistributionMeter from 'app/components/tagDistributionMeter';\nimport {IconWarning} from 'app/icons';\nimport {t} from 'app/locale';\nimport space from 'app/styles/space';\nimport {Organization} from 'app/types';\nimport {trackAnalyticsEvent} from 'app/utils/analytics';\nimport EventView, {isAPIPayloadSimilar} from 'app/utils/discover/eventView';\nimport withApi from 'app/utils/withApi';\n\ntype Props = {\n  api: Client;\n  organization: Organization;\n  eventView: EventView;\n  location: Location;\n  totalValues: null | number;\n  confirmedQuery?: boolean;\n  generateUrl: (key: string, value: string) => LocationDescriptor;\n};\n\ntype State = {\n  loading: boolean;\n  tags: Tag[];\n  totalValues: null | number;\n  error: string;\n};\n\nclass Tags extends Component<Props, State> {\n  state: State = {\n    loading: true,\n    tags: [],\n    totalValues: null,\n    error: '',\n  };\n\n  componentDidMount() {\n    this.fetchData(true);\n  }\n\n  componentDidUpdate(prevProps: Props) {\n    if (\n      this.shouldRefetchData(prevProps) ||\n      prevProps.confirmedQuery !== this.props.confirmedQuery\n    ) {\n      this.fetchData();\n    }\n  }\n\n  shouldRefetchData = (prevProps: Props): boolean => {\n    const thisAPIPayload = this.props.eventView.getFacetsAPIPayload(this.props.location);\n    const otherAPIPayload = prevProps.eventView.getFacetsAPIPayload(prevProps.location);\n\n    return !isAPIPayloadSimilar(thisAPIPayload, otherAPIPayload);\n  };\n\n  fetchData = async (forceFetchData = false) => {\n    const {api, organization, eventView, location, confirmedQuery} = this.props;\n    this.setState({loading: true, error: '', tags: []});\n\n    // Fetch should be forced after mounting as confirmedQuery isn't guaranteed\n    // since this component can mount/unmount via show/hide tags separate from\n    // data being loaded for the rest of the page.\n    if (!forceFetchData && confirmedQuery === false) {\n      return;\n    }\n\n    try {\n      const tags = await fetchTagFacets(\n        api,\n        organization.slug,\n        eventView.getFacetsAPIPayload(location)\n      );\n      this.setState({loading: false, tags});\n    } catch (err) {\n      Sentry.captureException(err);\n      this.setState({loading: false, error: err});\n    }\n  };\n\n  handleTagClick = (tag: string) => {\n    const {organization} = this.props;\n    // metrics\n    trackAnalyticsEvent({\n      eventKey: 'discover_v2.facet_map.clicked',\n      eventName: 'Discoverv2: Clicked on a tag on the facet map',\n      tag,\n      organization_id: parseInt(organization.id, 10),\n    });\n  };\n\n  renderTag(tag: Tag) {\n    const {generateUrl, totalValues} = this.props;\n\n    const segments: TagSegment[] = tag.topValues.map(segment => {\n      segment.url = generateUrl(tag.key, segment.value);\n\n      return segment;\n    });\n    // Ensure we don't show >100% if there's a slight mismatch between the facets\n    // endpoint and the totals endpoint\n    const maxTotalValues =\n      segments.length > 0\n        ? Math.max(Number(totalValues), segments[0].count)\n        : totalValues;\n    return (\n      <TagDistributionMeter\n        key={tag.key}\n        title={tag.key}\n        segments={segments}\n        totalValues={Number(maxTotalValues)}\n        renderLoading={() => <StyledPlaceholder height=\"16px\" />}\n        onTagClick={this.handleTagClick}\n        showReleasePackage\n      />\n    );\n  }\n\n  renderPlaceholders() {\n    return (\n      <Fragment>\n        <StyledPlaceholderTitle key=\"title-1\" />\n        <StyledPlaceholder key=\"bar-1\" />\n        <StyledPlaceholderTitle key=\"title-2\" />\n        <StyledPlaceholder key=\"bar-2\" />\n        <StyledPlaceholderTitle key=\"title-3\" />\n        <StyledPlaceholder key=\"bar-3\" />\n      </Fragment>\n    );\n  }\n\n  renderBody = () => {\n    const {loading, error, tags} = this.state;\n    if (loading) {\n      return this.renderPlaceholders();\n    }\n    if (error) {\n      return (\n        <ErrorPanel height=\"132px\">\n          <IconWarning color=\"gray300\" size=\"lg\" />\n        </ErrorPanel>\n      );\n    }\n    if (tags.length > 0) {\n      return tags.map(tag => this.renderTag(tag));\n    } else {\n      return (\n        <StyledEmptyStateWarning small>{t('No tags found')}</StyledEmptyStateWarning>\n      );\n    }\n  };\n\n  render() {\n    return (\n      <Fragment>\n        <SectionHeading>{t('Tag Summary')}</SectionHeading>\n        {this.renderBody()}\n      </Fragment>\n    );\n  }\n}\n\nconst StyledEmptyStateWarning = styled(EmptyStateWarning)`\n  height: 132px;\n  padding: 54px 15%;\n`;\n\nconst StyledPlaceholder = styled(Placeholder)`\n  border-radius: ${p => p.theme.borderRadius};\n  height: 16px;\n  margin-bottom: ${space(1.5)};\n`;\n\nconst StyledPlaceholderTitle = styled(Placeholder)`\n  width: 100px;\n  height: 12px;\n  margin-bottom: ${space(0.5)};\n`;\n\nexport {Tags};\nexport default withApi(Tags);\n","import {LocationDescriptor, Query} from 'history';\n\nimport {PAGE_URL_PARAM} from 'app/constants/globalSelectionHeader';\nimport {OrganizationSummary} from 'app/types';\nimport {TraceFullDetailed} from 'app/utils/performance/quickTrace/types';\nimport {reduceTrace} from 'app/utils/performance/quickTrace/utils';\n\nimport {TraceInfo} from './types';\n\nexport function getTraceDetailsUrl(\n  organization: OrganizationSummary,\n  traceSlug: string,\n  dateSelection,\n  query: Query\n): LocationDescriptor {\n  const {start, end, statsPeriod} = dateSelection;\n  return {\n    pathname: `/organizations/${organization.slug}/performance/trace/${traceSlug}/`,\n    query: {\n      ...query,\n      statsPeriod,\n      [PAGE_URL_PARAM.PAGE_START]: start,\n      [PAGE_URL_PARAM.PAGE_END]: end,\n    },\n  };\n}\n\nfunction traceVisitor() {\n  return (accumulator: TraceInfo, event: TraceFullDetailed) => {\n    for (const error of event.errors ?? []) {\n      accumulator.errors.add(error.event_id);\n    }\n\n    accumulator.transactions.add(event.event_id);\n    accumulator.projects.add(event.project_slug);\n\n    accumulator.startTimestamp = Math.min(\n      accumulator.startTimestamp,\n      event.start_timestamp\n    );\n    accumulator.endTimestamp = Math.max(accumulator.endTimestamp, event.timestamp);\n\n    accumulator.maxGeneration = Math.max(accumulator.maxGeneration, event.generation);\n\n    return accumulator;\n  };\n}\n\nexport function getTraceInfo(traces: TraceFullDetailed[]) {\n  const initial = {\n    projects: new Set<string>(),\n    errors: new Set<string>(),\n    transactions: new Set<string>(),\n    startTimestamp: Number.MAX_SAFE_INTEGER,\n    endTimestamp: 0,\n    maxGeneration: 0,\n  };\n\n  return traces.reduce(\n    (info: TraceInfo, trace: TraceFullDetailed) =>\n      reduceTrace<TraceInfo>(trace, traceVisitor(), info),\n    initial\n  );\n}\n\nexport function isRootTransaction(trace: TraceFullDetailed): boolean {\n  // Root transactions has no parent_span_id\n  return trace.parent_span_id === null;\n}\n"],"sourceRoot":""}