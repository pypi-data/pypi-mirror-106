Metadata-Version: 2.1
Name: python-easy-rsa
Version: 1.0.1
Summary: Python Easy RSA is a wrapper that allows decryption, encryption, signing, and verifying signature simpler. You can load your keys from a file or from a string. It is easy to use, fast and free!
Home-page: https://github.com/iamoracle/python-easy-rsa
Author: iamoracle
Author-email: officialbilas@gmail.com
License: MIT
Download-URL: https://github.com/iamoracle/python-easy-rsa/archive/refs/tags/v1.0.1.tar.gz
Keywords: Python,RSA,Easy,generate public key,generate private key,encrypt,decrypt,using python
Platform: UNKNOWN
Classifier: Development Status :: 3 - Alpha
Classifier: Intended Audience :: Developers
Classifier: Topic :: Software Development :: Build Tools
Classifier: License :: OSI Approved :: MIT License
Classifier: Programming Language :: Python :: 3
Classifier: Programming Language :: Python :: 3.4
Classifier: Programming Language :: Python :: 3.5
Classifier: Programming Language :: Python :: 3.6
Classifier: Programming Language :: Python :: 3.7
Classifier: Programming Language :: Python :: 3.8
Classifier: Programming Language :: Python :: 3.9
Classifier: Programming Language :: Python :: 3.10
Description-Content-Type: text/markdown
Requires-Dist: pathlib
Requires-Dist: pycryptodome

# Python Easy RSA

[![Upload Python Package](https://github.com/iamoracle/python-easy-rsa/actions/workflows/python-publish.yml/badge.svg)](https://github.com/iamoracle/python-easy-rsa/actions/workflows/python-publish.yml)

Python Easy RSA is a wrapper that allows decryption, encryption, signing, and verifying signature simpler. You can load your keys from a file or from a string. It is easy to use, fast and free!

## Generating Public and Private Key 

```python

# the directory where the keys are to be stored
# in this case we are using the current file directory
path = Path(__file__).absolute().parent

# initialize the encrypter
encryption = Encryption(path, name=('public_key.pem', 'private1.pem'))

# generates both private and public keys
encryption.generate_keys()
```

## Loading Existing Private and Public Key


```python

# the directory where the keys are to be stored
# in this case we are using the current file directory
path = Path(__file__).absolute().parent

# initialize the encrypter
encryption = Encryption(path, name=('public_key.pem', 'private1.pem'))

# loads both private and public keys
encryption.load_keys()

# at this point both public and private keys are loaded in memory
# check example below to encrypt using the load or generate keys

```

## Encrypting a message

```python
# the directory where the keys are to be stored
# in this case we are using the current file directory
path = Path(__file__).absolute().parent

# initialize the encrypter
encryption = Encryption(path, name=('public_key.pem', 'private1.pem'))

# generates or load both private and public keys
encryption.load_keys() # or encryption.generate_keys()

encrypted = encryption.encrypt('hello world')

# return encrypted string

decrypted = encryption.decrypt(encrypted)

# returns a decrypted message 
# 'hello world'
```


## Encrypt with a custom key from a custom file

```python
# one time encryption

# load a public key file
file_content = open('file.pem')

encryption = Encryption()

encrypted = encryption.encrypt('hello world', file_content)
```


## Decrypt with a custom key from a custom file

```python
# one time decryption

file_content = open('file.pem')

encryption = Encryption()

encrypted_message = 'somethin encrypted'

decrypted = encryption.decrypt('hello world', file_content)

# returns a decrypted message
```


## Sign and Verify Message

```python
# loads key from file
encryption = Encryption(path, name=('public_key.pem', 'private1.pem'))

# generates or load both private and public keys
encryption.load_keys() # or encryption.generate_keys()

# sign a string with a private key
hash = encryption.sign('hello world') # or encryption.sign('hello world', private_key_rfrom_file)
# returns a signed hash 

# verify if a message is signed by a private key using its counter public key 
verified = encryption.verify_sign('hello world', hash) # or encryption.verify_sign('hello world', hash, public_key_from_file)
# returns bool
```


