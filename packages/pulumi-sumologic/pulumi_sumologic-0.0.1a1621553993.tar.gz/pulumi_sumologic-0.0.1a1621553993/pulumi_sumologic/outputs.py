# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
from . import _utilities
from . import outputs

__all__ = [
    'AwsInventorySourceAuthentication',
    'AwsInventorySourceDefaultDateFormat',
    'AwsInventorySourceFilter',
    'AwsInventorySourcePath',
    'AwsInventorySourcePathTagFilter',
    'AwsXraySourceAuthentication',
    'AwsXraySourceDefaultDateFormat',
    'AwsXraySourceFilter',
    'AwsXraySourcePath',
    'AwsXraySourcePathTagFilter',
    'CloudSyslogSourceDefaultDateFormat',
    'CloudSyslogSourceFilter',
    'CloudfrontSourceAuthentication',
    'CloudfrontSourceDefaultDateFormat',
    'CloudfrontSourceFilter',
    'CloudfrontSourcePath',
    'CloudfrontSourcePathTagFilter',
    'CloudtrailSourceAuthentication',
    'CloudtrailSourceDefaultDateFormat',
    'CloudtrailSourceFilter',
    'CloudtrailSourcePath',
    'CloudtrailSourcePathTagFilter',
    'CloudwatchSourceAuthentication',
    'CloudwatchSourceDefaultDateFormat',
    'CloudwatchSourceFilter',
    'CloudwatchSourcePath',
    'CloudwatchSourcePathTagFilter',
    'DashboardColoringRule',
    'DashboardColoringRuleColorThreshold',
    'DashboardLayout',
    'DashboardLayoutGrid',
    'DashboardLayoutGridLayoutStructure',
    'DashboardPanel',
    'DashboardPanelSumoSearchPanel',
    'DashboardPanelSumoSearchPanelColoringRule',
    'DashboardPanelSumoSearchPanelColoringRuleColorThreshold',
    'DashboardPanelSumoSearchPanelLinkedDashboard',
    'DashboardPanelSumoSearchPanelQuery',
    'DashboardPanelSumoSearchPanelQueryMetricsQueryData',
    'DashboardPanelSumoSearchPanelQueryMetricsQueryDataFilter',
    'DashboardPanelSumoSearchPanelQueryMetricsQueryDataOperator',
    'DashboardPanelSumoSearchPanelQueryMetricsQueryDataOperatorParameter',
    'DashboardPanelSumoSearchPanelTimeRange',
    'DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRange',
    'DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeFrom',
    'DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeFromEpochTimeRange',
    'DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeFromIso8601TimeRange',
    'DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeFromLiteralTimeRange',
    'DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeFromRelativeTimeRange',
    'DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeTo',
    'DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeToEpochTimeRange',
    'DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeToIso8601TimeRange',
    'DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeToLiteralTimeRange',
    'DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeToRelativeTimeRange',
    'DashboardPanelSumoSearchPanelTimeRangeCompleteLiteralTimeRange',
    'DashboardPanelTextPanel',
    'DashboardTimeRange',
    'DashboardTimeRangeBeginBoundedTimeRange',
    'DashboardTimeRangeBeginBoundedTimeRangeFrom',
    'DashboardTimeRangeBeginBoundedTimeRangeFromEpochTimeRange',
    'DashboardTimeRangeBeginBoundedTimeRangeFromIso8601TimeRange',
    'DashboardTimeRangeBeginBoundedTimeRangeFromLiteralTimeRange',
    'DashboardTimeRangeBeginBoundedTimeRangeFromRelativeTimeRange',
    'DashboardTimeRangeBeginBoundedTimeRangeTo',
    'DashboardTimeRangeBeginBoundedTimeRangeToEpochTimeRange',
    'DashboardTimeRangeBeginBoundedTimeRangeToIso8601TimeRange',
    'DashboardTimeRangeBeginBoundedTimeRangeToLiteralTimeRange',
    'DashboardTimeRangeBeginBoundedTimeRangeToRelativeTimeRange',
    'DashboardTimeRangeCompleteLiteralTimeRange',
    'DashboardTopologyLabelMap',
    'DashboardTopologyLabelMapData',
    'DashboardVariable',
    'DashboardVariableSourceDefinition',
    'DashboardVariableSourceDefinitionCsvVariableSourceDefinition',
    'DashboardVariableSourceDefinitionLogQueryVariableSourceDefinition',
    'DashboardVariableSourceDefinitionMetadataVariableSourceDefinition',
    'ElbSourceAuthentication',
    'ElbSourceDefaultDateFormat',
    'ElbSourceFilter',
    'ElbSourcePath',
    'ElbSourcePathTagFilter',
    'GcpSourceAuthentication',
    'GcpSourceDefaultDateFormat',
    'GcpSourceFilter',
    'GcpSourcePath',
    'HttpSourceDefaultDateFormat',
    'HttpSourceFilter',
    'KinesisMetricsSourceAuthentication',
    'KinesisMetricsSourceDefaultDateFormat',
    'KinesisMetricsSourceFilter',
    'KinesisMetricsSourcePath',
    'KinesisMetricsSourcePathTagFilter',
    'LookupTableField',
    'MetadataSourceAuthentication',
    'MetadataSourceDefaultDateFormat',
    'MetadataSourceFilter',
    'MetadataSourcePath',
    'MonitorNotification',
    'MonitorNotificationNotification',
    'MonitorQuery',
    'MonitorTrigger',
    'PollingSourceAuthentication',
    'PollingSourceDefaultDateFormat',
    'PollingSourceFilter',
    'PollingSourcePath',
    'PollingSourcePathTagFilter',
    'S3AuditSourceAuthentication',
    'S3AuditSourceDefaultDateFormat',
    'S3AuditSourceFilter',
    'S3AuditSourcePath',
    'S3AuditSourcePathTagFilter',
    'S3SourceAuthentication',
    'S3SourceDefaultDateFormat',
    'S3SourceFilter',
    'S3SourcePath',
    'S3SourcePathTagFilter',
    'SamlConfigurationOnDemandProvisioningEnabled',
]

@pulumi.output_type
class AwsInventorySourceAuthentication(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessKey":
            suggest = "access_key"
        elif key == "roleArn":
            suggest = "role_arn"
        elif key == "secretKey":
            suggest = "secret_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AwsInventorySourceAuthentication. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AwsInventorySourceAuthentication.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AwsInventorySourceAuthentication.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: str,
                 access_key: Optional[str] = None,
                 role_arn: Optional[str] = None,
                 secret_key: Optional[str] = None):
        pulumi.set(__self__, "type", type)
        if access_key is not None:
            pulumi.set(__self__, "access_key", access_key)
        if role_arn is not None:
            pulumi.set(__self__, "role_arn", role_arn)
        if secret_key is not None:
            pulumi.set(__self__, "secret_key", secret_key)

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="accessKey")
    def access_key(self) -> Optional[str]:
        return pulumi.get(self, "access_key")

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> Optional[str]:
        return pulumi.get(self, "role_arn")

    @property
    @pulumi.getter(name="secretKey")
    def secret_key(self) -> Optional[str]:
        return pulumi.get(self, "secret_key")


@pulumi.output_type
class AwsInventorySourceDefaultDateFormat(dict):
    def __init__(__self__, *,
                 format: str,
                 locator: Optional[str] = None):
        pulumi.set(__self__, "format", format)
        if locator is not None:
            pulumi.set(__self__, "locator", locator)

    @property
    @pulumi.getter
    def format(self) -> str:
        return pulumi.get(self, "format")

    @property
    @pulumi.getter
    def locator(self) -> Optional[str]:
        return pulumi.get(self, "locator")


@pulumi.output_type
class AwsInventorySourceFilter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "filterType":
            suggest = "filter_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AwsInventorySourceFilter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AwsInventorySourceFilter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AwsInventorySourceFilter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 filter_type: str,
                 name: str,
                 regexp: str,
                 mask: Optional[str] = None):
        pulumi.set(__self__, "filter_type", filter_type)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "regexp", regexp)
        if mask is not None:
            pulumi.set(__self__, "mask", mask)

    @property
    @pulumi.getter(name="filterType")
    def filter_type(self) -> str:
        return pulumi.get(self, "filter_type")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def regexp(self) -> str:
        return pulumi.get(self, "regexp")

    @property
    @pulumi.getter
    def mask(self) -> Optional[str]:
        return pulumi.get(self, "mask")


@pulumi.output_type
class AwsInventorySourcePath(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bucketName":
            suggest = "bucket_name"
        elif key == "limitToNamespaces":
            suggest = "limit_to_namespaces"
        elif key == "limitToRegions":
            suggest = "limit_to_regions"
        elif key == "pathExpression":
            suggest = "path_expression"
        elif key == "tagFilters":
            suggest = "tag_filters"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AwsInventorySourcePath. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AwsInventorySourcePath.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AwsInventorySourcePath.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: str,
                 bucket_name: Optional[str] = None,
                 limit_to_namespaces: Optional[Sequence[str]] = None,
                 limit_to_regions: Optional[Sequence[str]] = None,
                 path_expression: Optional[str] = None,
                 tag_filters: Optional[Sequence['outputs.AwsInventorySourcePathTagFilter']] = None):
        pulumi.set(__self__, "type", type)
        if bucket_name is not None:
            pulumi.set(__self__, "bucket_name", bucket_name)
        if limit_to_namespaces is not None:
            pulumi.set(__self__, "limit_to_namespaces", limit_to_namespaces)
        if limit_to_regions is not None:
            pulumi.set(__self__, "limit_to_regions", limit_to_regions)
        if path_expression is not None:
            pulumi.set(__self__, "path_expression", path_expression)
        if tag_filters is not None:
            pulumi.set(__self__, "tag_filters", tag_filters)

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="bucketName")
    def bucket_name(self) -> Optional[str]:
        return pulumi.get(self, "bucket_name")

    @property
    @pulumi.getter(name="limitToNamespaces")
    def limit_to_namespaces(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "limit_to_namespaces")

    @property
    @pulumi.getter(name="limitToRegions")
    def limit_to_regions(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "limit_to_regions")

    @property
    @pulumi.getter(name="pathExpression")
    def path_expression(self) -> Optional[str]:
        return pulumi.get(self, "path_expression")

    @property
    @pulumi.getter(name="tagFilters")
    def tag_filters(self) -> Optional[Sequence['outputs.AwsInventorySourcePathTagFilter']]:
        return pulumi.get(self, "tag_filters")


@pulumi.output_type
class AwsInventorySourcePathTagFilter(dict):
    def __init__(__self__, *,
                 namespace: Optional[str] = None,
                 tags: Optional[Sequence[str]] = None,
                 type: Optional[str] = None):
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def namespace(self) -> Optional[str]:
        return pulumi.get(self, "namespace")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")


@pulumi.output_type
class AwsXraySourceAuthentication(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessKey":
            suggest = "access_key"
        elif key == "roleArn":
            suggest = "role_arn"
        elif key == "secretKey":
            suggest = "secret_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AwsXraySourceAuthentication. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AwsXraySourceAuthentication.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AwsXraySourceAuthentication.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: str,
                 access_key: Optional[str] = None,
                 role_arn: Optional[str] = None,
                 secret_key: Optional[str] = None):
        pulumi.set(__self__, "type", type)
        if access_key is not None:
            pulumi.set(__self__, "access_key", access_key)
        if role_arn is not None:
            pulumi.set(__self__, "role_arn", role_arn)
        if secret_key is not None:
            pulumi.set(__self__, "secret_key", secret_key)

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="accessKey")
    def access_key(self) -> Optional[str]:
        return pulumi.get(self, "access_key")

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> Optional[str]:
        return pulumi.get(self, "role_arn")

    @property
    @pulumi.getter(name="secretKey")
    def secret_key(self) -> Optional[str]:
        return pulumi.get(self, "secret_key")


@pulumi.output_type
class AwsXraySourceDefaultDateFormat(dict):
    def __init__(__self__, *,
                 format: str,
                 locator: Optional[str] = None):
        pulumi.set(__self__, "format", format)
        if locator is not None:
            pulumi.set(__self__, "locator", locator)

    @property
    @pulumi.getter
    def format(self) -> str:
        return pulumi.get(self, "format")

    @property
    @pulumi.getter
    def locator(self) -> Optional[str]:
        return pulumi.get(self, "locator")


@pulumi.output_type
class AwsXraySourceFilter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "filterType":
            suggest = "filter_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AwsXraySourceFilter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AwsXraySourceFilter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AwsXraySourceFilter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 filter_type: str,
                 name: str,
                 regexp: str,
                 mask: Optional[str] = None):
        pulumi.set(__self__, "filter_type", filter_type)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "regexp", regexp)
        if mask is not None:
            pulumi.set(__self__, "mask", mask)

    @property
    @pulumi.getter(name="filterType")
    def filter_type(self) -> str:
        return pulumi.get(self, "filter_type")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def regexp(self) -> str:
        return pulumi.get(self, "regexp")

    @property
    @pulumi.getter
    def mask(self) -> Optional[str]:
        return pulumi.get(self, "mask")


@pulumi.output_type
class AwsXraySourcePath(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bucketName":
            suggest = "bucket_name"
        elif key == "limitToNamespaces":
            suggest = "limit_to_namespaces"
        elif key == "limitToRegions":
            suggest = "limit_to_regions"
        elif key == "pathExpression":
            suggest = "path_expression"
        elif key == "tagFilters":
            suggest = "tag_filters"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AwsXraySourcePath. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AwsXraySourcePath.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AwsXraySourcePath.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: str,
                 bucket_name: Optional[str] = None,
                 limit_to_namespaces: Optional[Sequence[str]] = None,
                 limit_to_regions: Optional[Sequence[str]] = None,
                 path_expression: Optional[str] = None,
                 tag_filters: Optional[Sequence['outputs.AwsXraySourcePathTagFilter']] = None):
        pulumi.set(__self__, "type", type)
        if bucket_name is not None:
            pulumi.set(__self__, "bucket_name", bucket_name)
        if limit_to_namespaces is not None:
            pulumi.set(__self__, "limit_to_namespaces", limit_to_namespaces)
        if limit_to_regions is not None:
            pulumi.set(__self__, "limit_to_regions", limit_to_regions)
        if path_expression is not None:
            pulumi.set(__self__, "path_expression", path_expression)
        if tag_filters is not None:
            pulumi.set(__self__, "tag_filters", tag_filters)

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="bucketName")
    def bucket_name(self) -> Optional[str]:
        return pulumi.get(self, "bucket_name")

    @property
    @pulumi.getter(name="limitToNamespaces")
    def limit_to_namespaces(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "limit_to_namespaces")

    @property
    @pulumi.getter(name="limitToRegions")
    def limit_to_regions(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "limit_to_regions")

    @property
    @pulumi.getter(name="pathExpression")
    def path_expression(self) -> Optional[str]:
        return pulumi.get(self, "path_expression")

    @property
    @pulumi.getter(name="tagFilters")
    def tag_filters(self) -> Optional[Sequence['outputs.AwsXraySourcePathTagFilter']]:
        return pulumi.get(self, "tag_filters")


@pulumi.output_type
class AwsXraySourcePathTagFilter(dict):
    def __init__(__self__, *,
                 namespace: Optional[str] = None,
                 tags: Optional[Sequence[str]] = None,
                 type: Optional[str] = None):
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def namespace(self) -> Optional[str]:
        return pulumi.get(self, "namespace")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")


@pulumi.output_type
class CloudSyslogSourceDefaultDateFormat(dict):
    def __init__(__self__, *,
                 format: str,
                 locator: Optional[str] = None):
        pulumi.set(__self__, "format", format)
        if locator is not None:
            pulumi.set(__self__, "locator", locator)

    @property
    @pulumi.getter
    def format(self) -> str:
        return pulumi.get(self, "format")

    @property
    @pulumi.getter
    def locator(self) -> Optional[str]:
        return pulumi.get(self, "locator")


@pulumi.output_type
class CloudSyslogSourceFilter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "filterType":
            suggest = "filter_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CloudSyslogSourceFilter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CloudSyslogSourceFilter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CloudSyslogSourceFilter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 filter_type: str,
                 name: str,
                 regexp: str,
                 mask: Optional[str] = None):
        pulumi.set(__self__, "filter_type", filter_type)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "regexp", regexp)
        if mask is not None:
            pulumi.set(__self__, "mask", mask)

    @property
    @pulumi.getter(name="filterType")
    def filter_type(self) -> str:
        return pulumi.get(self, "filter_type")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def regexp(self) -> str:
        return pulumi.get(self, "regexp")

    @property
    @pulumi.getter
    def mask(self) -> Optional[str]:
        return pulumi.get(self, "mask")


@pulumi.output_type
class CloudfrontSourceAuthentication(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessKey":
            suggest = "access_key"
        elif key == "roleArn":
            suggest = "role_arn"
        elif key == "secretKey":
            suggest = "secret_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CloudfrontSourceAuthentication. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CloudfrontSourceAuthentication.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CloudfrontSourceAuthentication.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: str,
                 access_key: Optional[str] = None,
                 role_arn: Optional[str] = None,
                 secret_key: Optional[str] = None):
        pulumi.set(__self__, "type", type)
        if access_key is not None:
            pulumi.set(__self__, "access_key", access_key)
        if role_arn is not None:
            pulumi.set(__self__, "role_arn", role_arn)
        if secret_key is not None:
            pulumi.set(__self__, "secret_key", secret_key)

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="accessKey")
    def access_key(self) -> Optional[str]:
        return pulumi.get(self, "access_key")

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> Optional[str]:
        return pulumi.get(self, "role_arn")

    @property
    @pulumi.getter(name="secretKey")
    def secret_key(self) -> Optional[str]:
        return pulumi.get(self, "secret_key")


@pulumi.output_type
class CloudfrontSourceDefaultDateFormat(dict):
    def __init__(__self__, *,
                 format: str,
                 locator: Optional[str] = None):
        pulumi.set(__self__, "format", format)
        if locator is not None:
            pulumi.set(__self__, "locator", locator)

    @property
    @pulumi.getter
    def format(self) -> str:
        return pulumi.get(self, "format")

    @property
    @pulumi.getter
    def locator(self) -> Optional[str]:
        return pulumi.get(self, "locator")


@pulumi.output_type
class CloudfrontSourceFilter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "filterType":
            suggest = "filter_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CloudfrontSourceFilter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CloudfrontSourceFilter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CloudfrontSourceFilter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 filter_type: str,
                 name: str,
                 regexp: str,
                 mask: Optional[str] = None):
        pulumi.set(__self__, "filter_type", filter_type)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "regexp", regexp)
        if mask is not None:
            pulumi.set(__self__, "mask", mask)

    @property
    @pulumi.getter(name="filterType")
    def filter_type(self) -> str:
        return pulumi.get(self, "filter_type")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def regexp(self) -> str:
        return pulumi.get(self, "regexp")

    @property
    @pulumi.getter
    def mask(self) -> Optional[str]:
        return pulumi.get(self, "mask")


@pulumi.output_type
class CloudfrontSourcePath(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bucketName":
            suggest = "bucket_name"
        elif key == "limitToNamespaces":
            suggest = "limit_to_namespaces"
        elif key == "limitToRegions":
            suggest = "limit_to_regions"
        elif key == "pathExpression":
            suggest = "path_expression"
        elif key == "tagFilters":
            suggest = "tag_filters"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CloudfrontSourcePath. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CloudfrontSourcePath.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CloudfrontSourcePath.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: str,
                 bucket_name: Optional[str] = None,
                 limit_to_namespaces: Optional[Sequence[str]] = None,
                 limit_to_regions: Optional[Sequence[str]] = None,
                 path_expression: Optional[str] = None,
                 tag_filters: Optional[Sequence['outputs.CloudfrontSourcePathTagFilter']] = None):
        pulumi.set(__self__, "type", type)
        if bucket_name is not None:
            pulumi.set(__self__, "bucket_name", bucket_name)
        if limit_to_namespaces is not None:
            pulumi.set(__self__, "limit_to_namespaces", limit_to_namespaces)
        if limit_to_regions is not None:
            pulumi.set(__self__, "limit_to_regions", limit_to_regions)
        if path_expression is not None:
            pulumi.set(__self__, "path_expression", path_expression)
        if tag_filters is not None:
            pulumi.set(__self__, "tag_filters", tag_filters)

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="bucketName")
    def bucket_name(self) -> Optional[str]:
        return pulumi.get(self, "bucket_name")

    @property
    @pulumi.getter(name="limitToNamespaces")
    def limit_to_namespaces(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "limit_to_namespaces")

    @property
    @pulumi.getter(name="limitToRegions")
    def limit_to_regions(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "limit_to_regions")

    @property
    @pulumi.getter(name="pathExpression")
    def path_expression(self) -> Optional[str]:
        return pulumi.get(self, "path_expression")

    @property
    @pulumi.getter(name="tagFilters")
    def tag_filters(self) -> Optional[Sequence['outputs.CloudfrontSourcePathTagFilter']]:
        return pulumi.get(self, "tag_filters")


@pulumi.output_type
class CloudfrontSourcePathTagFilter(dict):
    def __init__(__self__, *,
                 namespace: Optional[str] = None,
                 tags: Optional[Sequence[str]] = None,
                 type: Optional[str] = None):
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def namespace(self) -> Optional[str]:
        return pulumi.get(self, "namespace")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")


@pulumi.output_type
class CloudtrailSourceAuthentication(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessKey":
            suggest = "access_key"
        elif key == "roleArn":
            suggest = "role_arn"
        elif key == "secretKey":
            suggest = "secret_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CloudtrailSourceAuthentication. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CloudtrailSourceAuthentication.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CloudtrailSourceAuthentication.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: str,
                 access_key: Optional[str] = None,
                 role_arn: Optional[str] = None,
                 secret_key: Optional[str] = None):
        pulumi.set(__self__, "type", type)
        if access_key is not None:
            pulumi.set(__self__, "access_key", access_key)
        if role_arn is not None:
            pulumi.set(__self__, "role_arn", role_arn)
        if secret_key is not None:
            pulumi.set(__self__, "secret_key", secret_key)

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="accessKey")
    def access_key(self) -> Optional[str]:
        return pulumi.get(self, "access_key")

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> Optional[str]:
        return pulumi.get(self, "role_arn")

    @property
    @pulumi.getter(name="secretKey")
    def secret_key(self) -> Optional[str]:
        return pulumi.get(self, "secret_key")


@pulumi.output_type
class CloudtrailSourceDefaultDateFormat(dict):
    def __init__(__self__, *,
                 format: str,
                 locator: Optional[str] = None):
        pulumi.set(__self__, "format", format)
        if locator is not None:
            pulumi.set(__self__, "locator", locator)

    @property
    @pulumi.getter
    def format(self) -> str:
        return pulumi.get(self, "format")

    @property
    @pulumi.getter
    def locator(self) -> Optional[str]:
        return pulumi.get(self, "locator")


@pulumi.output_type
class CloudtrailSourceFilter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "filterType":
            suggest = "filter_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CloudtrailSourceFilter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CloudtrailSourceFilter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CloudtrailSourceFilter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 filter_type: str,
                 name: str,
                 regexp: str,
                 mask: Optional[str] = None):
        pulumi.set(__self__, "filter_type", filter_type)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "regexp", regexp)
        if mask is not None:
            pulumi.set(__self__, "mask", mask)

    @property
    @pulumi.getter(name="filterType")
    def filter_type(self) -> str:
        return pulumi.get(self, "filter_type")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def regexp(self) -> str:
        return pulumi.get(self, "regexp")

    @property
    @pulumi.getter
    def mask(self) -> Optional[str]:
        return pulumi.get(self, "mask")


@pulumi.output_type
class CloudtrailSourcePath(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bucketName":
            suggest = "bucket_name"
        elif key == "limitToNamespaces":
            suggest = "limit_to_namespaces"
        elif key == "limitToRegions":
            suggest = "limit_to_regions"
        elif key == "pathExpression":
            suggest = "path_expression"
        elif key == "tagFilters":
            suggest = "tag_filters"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CloudtrailSourcePath. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CloudtrailSourcePath.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CloudtrailSourcePath.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: str,
                 bucket_name: Optional[str] = None,
                 limit_to_namespaces: Optional[Sequence[str]] = None,
                 limit_to_regions: Optional[Sequence[str]] = None,
                 path_expression: Optional[str] = None,
                 tag_filters: Optional[Sequence['outputs.CloudtrailSourcePathTagFilter']] = None):
        pulumi.set(__self__, "type", type)
        if bucket_name is not None:
            pulumi.set(__self__, "bucket_name", bucket_name)
        if limit_to_namespaces is not None:
            pulumi.set(__self__, "limit_to_namespaces", limit_to_namespaces)
        if limit_to_regions is not None:
            pulumi.set(__self__, "limit_to_regions", limit_to_regions)
        if path_expression is not None:
            pulumi.set(__self__, "path_expression", path_expression)
        if tag_filters is not None:
            pulumi.set(__self__, "tag_filters", tag_filters)

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="bucketName")
    def bucket_name(self) -> Optional[str]:
        return pulumi.get(self, "bucket_name")

    @property
    @pulumi.getter(name="limitToNamespaces")
    def limit_to_namespaces(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "limit_to_namespaces")

    @property
    @pulumi.getter(name="limitToRegions")
    def limit_to_regions(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "limit_to_regions")

    @property
    @pulumi.getter(name="pathExpression")
    def path_expression(self) -> Optional[str]:
        return pulumi.get(self, "path_expression")

    @property
    @pulumi.getter(name="tagFilters")
    def tag_filters(self) -> Optional[Sequence['outputs.CloudtrailSourcePathTagFilter']]:
        return pulumi.get(self, "tag_filters")


@pulumi.output_type
class CloudtrailSourcePathTagFilter(dict):
    def __init__(__self__, *,
                 namespace: Optional[str] = None,
                 tags: Optional[Sequence[str]] = None,
                 type: Optional[str] = None):
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def namespace(self) -> Optional[str]:
        return pulumi.get(self, "namespace")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")


@pulumi.output_type
class CloudwatchSourceAuthentication(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessKey":
            suggest = "access_key"
        elif key == "roleArn":
            suggest = "role_arn"
        elif key == "secretKey":
            suggest = "secret_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CloudwatchSourceAuthentication. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CloudwatchSourceAuthentication.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CloudwatchSourceAuthentication.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: str,
                 access_key: Optional[str] = None,
                 role_arn: Optional[str] = None,
                 secret_key: Optional[str] = None):
        pulumi.set(__self__, "type", type)
        if access_key is not None:
            pulumi.set(__self__, "access_key", access_key)
        if role_arn is not None:
            pulumi.set(__self__, "role_arn", role_arn)
        if secret_key is not None:
            pulumi.set(__self__, "secret_key", secret_key)

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="accessKey")
    def access_key(self) -> Optional[str]:
        return pulumi.get(self, "access_key")

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> Optional[str]:
        return pulumi.get(self, "role_arn")

    @property
    @pulumi.getter(name="secretKey")
    def secret_key(self) -> Optional[str]:
        return pulumi.get(self, "secret_key")


@pulumi.output_type
class CloudwatchSourceDefaultDateFormat(dict):
    def __init__(__self__, *,
                 format: str,
                 locator: Optional[str] = None):
        pulumi.set(__self__, "format", format)
        if locator is not None:
            pulumi.set(__self__, "locator", locator)

    @property
    @pulumi.getter
    def format(self) -> str:
        return pulumi.get(self, "format")

    @property
    @pulumi.getter
    def locator(self) -> Optional[str]:
        return pulumi.get(self, "locator")


@pulumi.output_type
class CloudwatchSourceFilter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "filterType":
            suggest = "filter_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CloudwatchSourceFilter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CloudwatchSourceFilter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CloudwatchSourceFilter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 filter_type: str,
                 name: str,
                 regexp: str,
                 mask: Optional[str] = None):
        pulumi.set(__self__, "filter_type", filter_type)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "regexp", regexp)
        if mask is not None:
            pulumi.set(__self__, "mask", mask)

    @property
    @pulumi.getter(name="filterType")
    def filter_type(self) -> str:
        return pulumi.get(self, "filter_type")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def regexp(self) -> str:
        return pulumi.get(self, "regexp")

    @property
    @pulumi.getter
    def mask(self) -> Optional[str]:
        return pulumi.get(self, "mask")


@pulumi.output_type
class CloudwatchSourcePath(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bucketName":
            suggest = "bucket_name"
        elif key == "limitToNamespaces":
            suggest = "limit_to_namespaces"
        elif key == "limitToRegions":
            suggest = "limit_to_regions"
        elif key == "pathExpression":
            suggest = "path_expression"
        elif key == "tagFilters":
            suggest = "tag_filters"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CloudwatchSourcePath. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CloudwatchSourcePath.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CloudwatchSourcePath.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: str,
                 bucket_name: Optional[str] = None,
                 limit_to_namespaces: Optional[Sequence[str]] = None,
                 limit_to_regions: Optional[Sequence[str]] = None,
                 path_expression: Optional[str] = None,
                 tag_filters: Optional[Sequence['outputs.CloudwatchSourcePathTagFilter']] = None):
        pulumi.set(__self__, "type", type)
        if bucket_name is not None:
            pulumi.set(__self__, "bucket_name", bucket_name)
        if limit_to_namespaces is not None:
            pulumi.set(__self__, "limit_to_namespaces", limit_to_namespaces)
        if limit_to_regions is not None:
            pulumi.set(__self__, "limit_to_regions", limit_to_regions)
        if path_expression is not None:
            pulumi.set(__self__, "path_expression", path_expression)
        if tag_filters is not None:
            pulumi.set(__self__, "tag_filters", tag_filters)

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="bucketName")
    def bucket_name(self) -> Optional[str]:
        return pulumi.get(self, "bucket_name")

    @property
    @pulumi.getter(name="limitToNamespaces")
    def limit_to_namespaces(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "limit_to_namespaces")

    @property
    @pulumi.getter(name="limitToRegions")
    def limit_to_regions(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "limit_to_regions")

    @property
    @pulumi.getter(name="pathExpression")
    def path_expression(self) -> Optional[str]:
        return pulumi.get(self, "path_expression")

    @property
    @pulumi.getter(name="tagFilters")
    def tag_filters(self) -> Optional[Sequence['outputs.CloudwatchSourcePathTagFilter']]:
        return pulumi.get(self, "tag_filters")


@pulumi.output_type
class CloudwatchSourcePathTagFilter(dict):
    def __init__(__self__, *,
                 namespace: Optional[str] = None,
                 tags: Optional[Sequence[str]] = None,
                 type: Optional[str] = None):
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def namespace(self) -> Optional[str]:
        return pulumi.get(self, "namespace")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")


@pulumi.output_type
class DashboardColoringRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "multipleSeriesAggregateFunction":
            suggest = "multiple_series_aggregate_function"
        elif key == "singleSeriesAggregateFunction":
            suggest = "single_series_aggregate_function"
        elif key == "colorThresholds":
            suggest = "color_thresholds"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardColoringRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardColoringRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardColoringRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 multiple_series_aggregate_function: str,
                 scope: str,
                 single_series_aggregate_function: str,
                 color_thresholds: Optional[Sequence['outputs.DashboardColoringRuleColorThreshold']] = None):
        pulumi.set(__self__, "multiple_series_aggregate_function", multiple_series_aggregate_function)
        pulumi.set(__self__, "scope", scope)
        pulumi.set(__self__, "single_series_aggregate_function", single_series_aggregate_function)
        if color_thresholds is not None:
            pulumi.set(__self__, "color_thresholds", color_thresholds)

    @property
    @pulumi.getter(name="multipleSeriesAggregateFunction")
    def multiple_series_aggregate_function(self) -> str:
        return pulumi.get(self, "multiple_series_aggregate_function")

    @property
    @pulumi.getter
    def scope(self) -> str:
        return pulumi.get(self, "scope")

    @property
    @pulumi.getter(name="singleSeriesAggregateFunction")
    def single_series_aggregate_function(self) -> str:
        return pulumi.get(self, "single_series_aggregate_function")

    @property
    @pulumi.getter(name="colorThresholds")
    def color_thresholds(self) -> Optional[Sequence['outputs.DashboardColoringRuleColorThreshold']]:
        return pulumi.get(self, "color_thresholds")


@pulumi.output_type
class DashboardColoringRuleColorThreshold(dict):
    def __init__(__self__, *,
                 color: str,
                 max: Optional[float] = None,
                 min: Optional[float] = None):
        pulumi.set(__self__, "color", color)
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)

    @property
    @pulumi.getter
    def color(self) -> str:
        return pulumi.get(self, "color")

    @property
    @pulumi.getter
    def max(self) -> Optional[float]:
        return pulumi.get(self, "max")

    @property
    @pulumi.getter
    def min(self) -> Optional[float]:
        return pulumi.get(self, "min")


@pulumi.output_type
class DashboardLayout(dict):
    def __init__(__self__, *,
                 grid: Optional['outputs.DashboardLayoutGrid'] = None):
        if grid is not None:
            pulumi.set(__self__, "grid", grid)

    @property
    @pulumi.getter
    def grid(self) -> Optional['outputs.DashboardLayoutGrid']:
        return pulumi.get(self, "grid")


@pulumi.output_type
class DashboardLayoutGrid(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "layoutStructures":
            suggest = "layout_structures"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardLayoutGrid. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardLayoutGrid.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardLayoutGrid.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 layout_structures: Sequence['outputs.DashboardLayoutGridLayoutStructure']):
        pulumi.set(__self__, "layout_structures", layout_structures)

    @property
    @pulumi.getter(name="layoutStructures")
    def layout_structures(self) -> Sequence['outputs.DashboardLayoutGridLayoutStructure']:
        return pulumi.get(self, "layout_structures")


@pulumi.output_type
class DashboardLayoutGridLayoutStructure(dict):
    def __init__(__self__, *,
                 key: str,
                 structure: str):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "structure", structure)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def structure(self) -> str:
        return pulumi.get(self, "structure")


@pulumi.output_type
class DashboardPanel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sumoSearchPanel":
            suggest = "sumo_search_panel"
        elif key == "textPanel":
            suggest = "text_panel"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardPanel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardPanel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardPanel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 sumo_search_panel: Optional['outputs.DashboardPanelSumoSearchPanel'] = None,
                 text_panel: Optional['outputs.DashboardPanelTextPanel'] = None):
        if sumo_search_panel is not None:
            pulumi.set(__self__, "sumo_search_panel", sumo_search_panel)
        if text_panel is not None:
            pulumi.set(__self__, "text_panel", text_panel)

    @property
    @pulumi.getter(name="sumoSearchPanel")
    def sumo_search_panel(self) -> Optional['outputs.DashboardPanelSumoSearchPanel']:
        return pulumi.get(self, "sumo_search_panel")

    @property
    @pulumi.getter(name="textPanel")
    def text_panel(self) -> Optional['outputs.DashboardPanelTextPanel']:
        return pulumi.get(self, "text_panel")


@pulumi.output_type
class DashboardPanelSumoSearchPanel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "coloringRule":
            suggest = "coloring_rule"
        elif key == "keepVisualSettingsConsistentWithParent":
            suggest = "keep_visual_settings_consistent_with_parent"
        elif key == "linkedDashboard":
            suggest = "linked_dashboard"
        elif key == "timeRange":
            suggest = "time_range"
        elif key == "visualSettings":
            suggest = "visual_settings"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardPanelSumoSearchPanel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardPanelSumoSearchPanel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardPanelSumoSearchPanel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 key: str,
                 coloring_rule: Optional['outputs.DashboardPanelSumoSearchPanelColoringRule'] = None,
                 description: Optional[str] = None,
                 id: Optional[str] = None,
                 keep_visual_settings_consistent_with_parent: Optional[bool] = None,
                 linked_dashboard: Optional['outputs.DashboardPanelSumoSearchPanelLinkedDashboard'] = None,
                 queries: Optional[Sequence['outputs.DashboardPanelSumoSearchPanelQuery']] = None,
                 time_range: Optional['outputs.DashboardPanelSumoSearchPanelTimeRange'] = None,
                 title: Optional[str] = None,
                 visual_settings: Optional[str] = None):
        pulumi.set(__self__, "key", key)
        if coloring_rule is not None:
            pulumi.set(__self__, "coloring_rule", coloring_rule)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if keep_visual_settings_consistent_with_parent is not None:
            pulumi.set(__self__, "keep_visual_settings_consistent_with_parent", keep_visual_settings_consistent_with_parent)
        if linked_dashboard is not None:
            pulumi.set(__self__, "linked_dashboard", linked_dashboard)
        if queries is not None:
            pulumi.set(__self__, "queries", queries)
        if time_range is not None:
            pulumi.set(__self__, "time_range", time_range)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if visual_settings is not None:
            pulumi.set(__self__, "visual_settings", visual_settings)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter(name="coloringRule")
    def coloring_rule(self) -> Optional['outputs.DashboardPanelSumoSearchPanelColoringRule']:
        return pulumi.get(self, "coloring_rule")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="keepVisualSettingsConsistentWithParent")
    def keep_visual_settings_consistent_with_parent(self) -> Optional[bool]:
        return pulumi.get(self, "keep_visual_settings_consistent_with_parent")

    @property
    @pulumi.getter(name="linkedDashboard")
    def linked_dashboard(self) -> Optional['outputs.DashboardPanelSumoSearchPanelLinkedDashboard']:
        return pulumi.get(self, "linked_dashboard")

    @property
    @pulumi.getter
    def queries(self) -> Optional[Sequence['outputs.DashboardPanelSumoSearchPanelQuery']]:
        return pulumi.get(self, "queries")

    @property
    @pulumi.getter(name="timeRange")
    def time_range(self) -> Optional['outputs.DashboardPanelSumoSearchPanelTimeRange']:
        return pulumi.get(self, "time_range")

    @property
    @pulumi.getter
    def title(self) -> Optional[str]:
        return pulumi.get(self, "title")

    @property
    @pulumi.getter(name="visualSettings")
    def visual_settings(self) -> Optional[str]:
        return pulumi.get(self, "visual_settings")


@pulumi.output_type
class DashboardPanelSumoSearchPanelColoringRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "multipleSeriesAggregateFunction":
            suggest = "multiple_series_aggregate_function"
        elif key == "singleSeriesAggregateFunction":
            suggest = "single_series_aggregate_function"
        elif key == "colorThresholds":
            suggest = "color_thresholds"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardPanelSumoSearchPanelColoringRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardPanelSumoSearchPanelColoringRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardPanelSumoSearchPanelColoringRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 multiple_series_aggregate_function: str,
                 scope: str,
                 single_series_aggregate_function: str,
                 color_thresholds: Optional[Sequence['outputs.DashboardPanelSumoSearchPanelColoringRuleColorThreshold']] = None):
        pulumi.set(__self__, "multiple_series_aggregate_function", multiple_series_aggregate_function)
        pulumi.set(__self__, "scope", scope)
        pulumi.set(__self__, "single_series_aggregate_function", single_series_aggregate_function)
        if color_thresholds is not None:
            pulumi.set(__self__, "color_thresholds", color_thresholds)

    @property
    @pulumi.getter(name="multipleSeriesAggregateFunction")
    def multiple_series_aggregate_function(self) -> str:
        return pulumi.get(self, "multiple_series_aggregate_function")

    @property
    @pulumi.getter
    def scope(self) -> str:
        return pulumi.get(self, "scope")

    @property
    @pulumi.getter(name="singleSeriesAggregateFunction")
    def single_series_aggregate_function(self) -> str:
        return pulumi.get(self, "single_series_aggregate_function")

    @property
    @pulumi.getter(name="colorThresholds")
    def color_thresholds(self) -> Optional[Sequence['outputs.DashboardPanelSumoSearchPanelColoringRuleColorThreshold']]:
        return pulumi.get(self, "color_thresholds")


@pulumi.output_type
class DashboardPanelSumoSearchPanelColoringRuleColorThreshold(dict):
    def __init__(__self__, *,
                 color: str,
                 max: Optional[float] = None,
                 min: Optional[float] = None):
        pulumi.set(__self__, "color", color)
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)

    @property
    @pulumi.getter
    def color(self) -> str:
        return pulumi.get(self, "color")

    @property
    @pulumi.getter
    def max(self) -> Optional[float]:
        return pulumi.get(self, "max")

    @property
    @pulumi.getter
    def min(self) -> Optional[float]:
        return pulumi.get(self, "min")


@pulumi.output_type
class DashboardPanelSumoSearchPanelLinkedDashboard(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "includeTimeRange":
            suggest = "include_time_range"
        elif key == "includeVariables":
            suggest = "include_variables"
        elif key == "relativePath":
            suggest = "relative_path"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardPanelSumoSearchPanelLinkedDashboard. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardPanelSumoSearchPanelLinkedDashboard.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardPanelSumoSearchPanelLinkedDashboard.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 id: str,
                 include_time_range: Optional[bool] = None,
                 include_variables: Optional[bool] = None,
                 relative_path: Optional[str] = None):
        pulumi.set(__self__, "id", id)
        if include_time_range is not None:
            pulumi.set(__self__, "include_time_range", include_time_range)
        if include_variables is not None:
            pulumi.set(__self__, "include_variables", include_variables)
        if relative_path is not None:
            pulumi.set(__self__, "relative_path", relative_path)

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="includeTimeRange")
    def include_time_range(self) -> Optional[bool]:
        return pulumi.get(self, "include_time_range")

    @property
    @pulumi.getter(name="includeVariables")
    def include_variables(self) -> Optional[bool]:
        return pulumi.get(self, "include_variables")

    @property
    @pulumi.getter(name="relativePath")
    def relative_path(self) -> Optional[str]:
        return pulumi.get(self, "relative_path")


@pulumi.output_type
class DashboardPanelSumoSearchPanelQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "queryKey":
            suggest = "query_key"
        elif key == "queryString":
            suggest = "query_string"
        elif key == "queryType":
            suggest = "query_type"
        elif key == "metricsQueryData":
            suggest = "metrics_query_data"
        elif key == "metricsQueryMode":
            suggest = "metrics_query_mode"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardPanelSumoSearchPanelQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardPanelSumoSearchPanelQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardPanelSumoSearchPanelQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 query_key: str,
                 query_string: str,
                 query_type: str,
                 metrics_query_data: Optional['outputs.DashboardPanelSumoSearchPanelQueryMetricsQueryData'] = None,
                 metrics_query_mode: Optional[str] = None):
        pulumi.set(__self__, "query_key", query_key)
        pulumi.set(__self__, "query_string", query_string)
        pulumi.set(__self__, "query_type", query_type)
        if metrics_query_data is not None:
            pulumi.set(__self__, "metrics_query_data", metrics_query_data)
        if metrics_query_mode is not None:
            pulumi.set(__self__, "metrics_query_mode", metrics_query_mode)

    @property
    @pulumi.getter(name="queryKey")
    def query_key(self) -> str:
        return pulumi.get(self, "query_key")

    @property
    @pulumi.getter(name="queryString")
    def query_string(self) -> str:
        return pulumi.get(self, "query_string")

    @property
    @pulumi.getter(name="queryType")
    def query_type(self) -> str:
        return pulumi.get(self, "query_type")

    @property
    @pulumi.getter(name="metricsQueryData")
    def metrics_query_data(self) -> Optional['outputs.DashboardPanelSumoSearchPanelQueryMetricsQueryData']:
        return pulumi.get(self, "metrics_query_data")

    @property
    @pulumi.getter(name="metricsQueryMode")
    def metrics_query_mode(self) -> Optional[str]:
        return pulumi.get(self, "metrics_query_mode")


@pulumi.output_type
class DashboardPanelSumoSearchPanelQueryMetricsQueryData(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "aggregationType":
            suggest = "aggregation_type"
        elif key == "groupBy":
            suggest = "group_by"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardPanelSumoSearchPanelQueryMetricsQueryData. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardPanelSumoSearchPanelQueryMetricsQueryData.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardPanelSumoSearchPanelQueryMetricsQueryData.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 filters: Sequence['outputs.DashboardPanelSumoSearchPanelQueryMetricsQueryDataFilter'],
                 metric: str,
                 aggregation_type: Optional[str] = None,
                 group_by: Optional[str] = None,
                 operators: Optional[Sequence['outputs.DashboardPanelSumoSearchPanelQueryMetricsQueryDataOperator']] = None):
        pulumi.set(__self__, "filters", filters)
        pulumi.set(__self__, "metric", metric)
        if aggregation_type is not None:
            pulumi.set(__self__, "aggregation_type", aggregation_type)
        if group_by is not None:
            pulumi.set(__self__, "group_by", group_by)
        if operators is not None:
            pulumi.set(__self__, "operators", operators)

    @property
    @pulumi.getter
    def filters(self) -> Sequence['outputs.DashboardPanelSumoSearchPanelQueryMetricsQueryDataFilter']:
        return pulumi.get(self, "filters")

    @property
    @pulumi.getter
    def metric(self) -> str:
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter(name="aggregationType")
    def aggregation_type(self) -> Optional[str]:
        return pulumi.get(self, "aggregation_type")

    @property
    @pulumi.getter(name="groupBy")
    def group_by(self) -> Optional[str]:
        return pulumi.get(self, "group_by")

    @property
    @pulumi.getter
    def operators(self) -> Optional[Sequence['outputs.DashboardPanelSumoSearchPanelQueryMetricsQueryDataOperator']]:
        return pulumi.get(self, "operators")


@pulumi.output_type
class DashboardPanelSumoSearchPanelQueryMetricsQueryDataFilter(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str,
                 negation: Optional[bool] = None):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)
        if negation is not None:
            pulumi.set(__self__, "negation", negation)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")

    @property
    @pulumi.getter
    def negation(self) -> Optional[bool]:
        return pulumi.get(self, "negation")


@pulumi.output_type
class DashboardPanelSumoSearchPanelQueryMetricsQueryDataOperator(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "operatorName":
            suggest = "operator_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardPanelSumoSearchPanelQueryMetricsQueryDataOperator. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardPanelSumoSearchPanelQueryMetricsQueryDataOperator.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardPanelSumoSearchPanelQueryMetricsQueryDataOperator.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 operator_name: str,
                 parameters: Sequence['outputs.DashboardPanelSumoSearchPanelQueryMetricsQueryDataOperatorParameter']):
        pulumi.set(__self__, "operator_name", operator_name)
        pulumi.set(__self__, "parameters", parameters)

    @property
    @pulumi.getter(name="operatorName")
    def operator_name(self) -> str:
        return pulumi.get(self, "operator_name")

    @property
    @pulumi.getter
    def parameters(self) -> Sequence['outputs.DashboardPanelSumoSearchPanelQueryMetricsQueryDataOperatorParameter']:
        return pulumi.get(self, "parameters")


@pulumi.output_type
class DashboardPanelSumoSearchPanelQueryMetricsQueryDataOperatorParameter(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class DashboardPanelSumoSearchPanelTimeRange(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "beginBoundedTimeRange":
            suggest = "begin_bounded_time_range"
        elif key == "completeLiteralTimeRange":
            suggest = "complete_literal_time_range"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardPanelSumoSearchPanelTimeRange. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardPanelSumoSearchPanelTimeRange.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardPanelSumoSearchPanelTimeRange.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 begin_bounded_time_range: Optional['outputs.DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRange'] = None,
                 complete_literal_time_range: Optional['outputs.DashboardPanelSumoSearchPanelTimeRangeCompleteLiteralTimeRange'] = None):
        if begin_bounded_time_range is not None:
            pulumi.set(__self__, "begin_bounded_time_range", begin_bounded_time_range)
        if complete_literal_time_range is not None:
            pulumi.set(__self__, "complete_literal_time_range", complete_literal_time_range)

    @property
    @pulumi.getter(name="beginBoundedTimeRange")
    def begin_bounded_time_range(self) -> Optional['outputs.DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRange']:
        return pulumi.get(self, "begin_bounded_time_range")

    @property
    @pulumi.getter(name="completeLiteralTimeRange")
    def complete_literal_time_range(self) -> Optional['outputs.DashboardPanelSumoSearchPanelTimeRangeCompleteLiteralTimeRange']:
        return pulumi.get(self, "complete_literal_time_range")


@pulumi.output_type
class DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRange(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "from":
            suggest = "from_"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRange. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRange.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRange.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 from_: 'outputs.DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeFrom',
                 to: Optional['outputs.DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeTo'] = None):
        pulumi.set(__self__, "from_", from_)
        if to is not None:
            pulumi.set(__self__, "to", to)

    @property
    @pulumi.getter(name="from")
    def from_(self) -> 'outputs.DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeFrom':
        return pulumi.get(self, "from_")

    @property
    @pulumi.getter
    def to(self) -> Optional['outputs.DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeTo']:
        return pulumi.get(self, "to")


@pulumi.output_type
class DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeFrom(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "epochTimeRange":
            suggest = "epoch_time_range"
        elif key == "iso8601TimeRange":
            suggest = "iso8601_time_range"
        elif key == "literalTimeRange":
            suggest = "literal_time_range"
        elif key == "relativeTimeRange":
            suggest = "relative_time_range"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeFrom. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeFrom.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeFrom.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 epoch_time_range: Optional['outputs.DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeFromEpochTimeRange'] = None,
                 iso8601_time_range: Optional['outputs.DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeFromIso8601TimeRange'] = None,
                 literal_time_range: Optional['outputs.DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeFromLiteralTimeRange'] = None,
                 relative_time_range: Optional['outputs.DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeFromRelativeTimeRange'] = None):
        if epoch_time_range is not None:
            pulumi.set(__self__, "epoch_time_range", epoch_time_range)
        if iso8601_time_range is not None:
            pulumi.set(__self__, "iso8601_time_range", iso8601_time_range)
        if literal_time_range is not None:
            pulumi.set(__self__, "literal_time_range", literal_time_range)
        if relative_time_range is not None:
            pulumi.set(__self__, "relative_time_range", relative_time_range)

    @property
    @pulumi.getter(name="epochTimeRange")
    def epoch_time_range(self) -> Optional['outputs.DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeFromEpochTimeRange']:
        return pulumi.get(self, "epoch_time_range")

    @property
    @pulumi.getter(name="iso8601TimeRange")
    def iso8601_time_range(self) -> Optional['outputs.DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeFromIso8601TimeRange']:
        return pulumi.get(self, "iso8601_time_range")

    @property
    @pulumi.getter(name="literalTimeRange")
    def literal_time_range(self) -> Optional['outputs.DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeFromLiteralTimeRange']:
        return pulumi.get(self, "literal_time_range")

    @property
    @pulumi.getter(name="relativeTimeRange")
    def relative_time_range(self) -> Optional['outputs.DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeFromRelativeTimeRange']:
        return pulumi.get(self, "relative_time_range")


@pulumi.output_type
class DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeFromEpochTimeRange(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "epochMillis":
            suggest = "epoch_millis"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeFromEpochTimeRange. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeFromEpochTimeRange.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeFromEpochTimeRange.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 epoch_millis: int):
        pulumi.set(__self__, "epoch_millis", epoch_millis)

    @property
    @pulumi.getter(name="epochMillis")
    def epoch_millis(self) -> int:
        return pulumi.get(self, "epoch_millis")


@pulumi.output_type
class DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeFromIso8601TimeRange(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "iso8601Time":
            suggest = "iso8601_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeFromIso8601TimeRange. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeFromIso8601TimeRange.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeFromIso8601TimeRange.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 iso8601_time: str):
        pulumi.set(__self__, "iso8601_time", iso8601_time)

    @property
    @pulumi.getter(name="iso8601Time")
    def iso8601_time(self) -> str:
        return pulumi.get(self, "iso8601_time")


@pulumi.output_type
class DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeFromLiteralTimeRange(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "rangeName":
            suggest = "range_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeFromLiteralTimeRange. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeFromLiteralTimeRange.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeFromLiteralTimeRange.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 range_name: str):
        pulumi.set(__self__, "range_name", range_name)

    @property
    @pulumi.getter(name="rangeName")
    def range_name(self) -> str:
        return pulumi.get(self, "range_name")


@pulumi.output_type
class DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeFromRelativeTimeRange(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "relativeTime":
            suggest = "relative_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeFromRelativeTimeRange. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeFromRelativeTimeRange.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeFromRelativeTimeRange.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 relative_time: str):
        pulumi.set(__self__, "relative_time", relative_time)

    @property
    @pulumi.getter(name="relativeTime")
    def relative_time(self) -> str:
        return pulumi.get(self, "relative_time")


@pulumi.output_type
class DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeTo(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "epochTimeRange":
            suggest = "epoch_time_range"
        elif key == "iso8601TimeRange":
            suggest = "iso8601_time_range"
        elif key == "literalTimeRange":
            suggest = "literal_time_range"
        elif key == "relativeTimeRange":
            suggest = "relative_time_range"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeTo. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeTo.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeTo.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 epoch_time_range: Optional['outputs.DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeToEpochTimeRange'] = None,
                 iso8601_time_range: Optional['outputs.DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeToIso8601TimeRange'] = None,
                 literal_time_range: Optional['outputs.DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeToLiteralTimeRange'] = None,
                 relative_time_range: Optional['outputs.DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeToRelativeTimeRange'] = None):
        if epoch_time_range is not None:
            pulumi.set(__self__, "epoch_time_range", epoch_time_range)
        if iso8601_time_range is not None:
            pulumi.set(__self__, "iso8601_time_range", iso8601_time_range)
        if literal_time_range is not None:
            pulumi.set(__self__, "literal_time_range", literal_time_range)
        if relative_time_range is not None:
            pulumi.set(__self__, "relative_time_range", relative_time_range)

    @property
    @pulumi.getter(name="epochTimeRange")
    def epoch_time_range(self) -> Optional['outputs.DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeToEpochTimeRange']:
        return pulumi.get(self, "epoch_time_range")

    @property
    @pulumi.getter(name="iso8601TimeRange")
    def iso8601_time_range(self) -> Optional['outputs.DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeToIso8601TimeRange']:
        return pulumi.get(self, "iso8601_time_range")

    @property
    @pulumi.getter(name="literalTimeRange")
    def literal_time_range(self) -> Optional['outputs.DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeToLiteralTimeRange']:
        return pulumi.get(self, "literal_time_range")

    @property
    @pulumi.getter(name="relativeTimeRange")
    def relative_time_range(self) -> Optional['outputs.DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeToRelativeTimeRange']:
        return pulumi.get(self, "relative_time_range")


@pulumi.output_type
class DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeToEpochTimeRange(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "epochMillis":
            suggest = "epoch_millis"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeToEpochTimeRange. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeToEpochTimeRange.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeToEpochTimeRange.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 epoch_millis: int):
        pulumi.set(__self__, "epoch_millis", epoch_millis)

    @property
    @pulumi.getter(name="epochMillis")
    def epoch_millis(self) -> int:
        return pulumi.get(self, "epoch_millis")


@pulumi.output_type
class DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeToIso8601TimeRange(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "iso8601Time":
            suggest = "iso8601_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeToIso8601TimeRange. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeToIso8601TimeRange.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeToIso8601TimeRange.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 iso8601_time: str):
        pulumi.set(__self__, "iso8601_time", iso8601_time)

    @property
    @pulumi.getter(name="iso8601Time")
    def iso8601_time(self) -> str:
        return pulumi.get(self, "iso8601_time")


@pulumi.output_type
class DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeToLiteralTimeRange(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "rangeName":
            suggest = "range_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeToLiteralTimeRange. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeToLiteralTimeRange.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeToLiteralTimeRange.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 range_name: str):
        pulumi.set(__self__, "range_name", range_name)

    @property
    @pulumi.getter(name="rangeName")
    def range_name(self) -> str:
        return pulumi.get(self, "range_name")


@pulumi.output_type
class DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeToRelativeTimeRange(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "relativeTime":
            suggest = "relative_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeToRelativeTimeRange. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeToRelativeTimeRange.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeToRelativeTimeRange.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 relative_time: str):
        pulumi.set(__self__, "relative_time", relative_time)

    @property
    @pulumi.getter(name="relativeTime")
    def relative_time(self) -> str:
        return pulumi.get(self, "relative_time")


@pulumi.output_type
class DashboardPanelSumoSearchPanelTimeRangeCompleteLiteralTimeRange(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "rangeName":
            suggest = "range_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardPanelSumoSearchPanelTimeRangeCompleteLiteralTimeRange. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardPanelSumoSearchPanelTimeRangeCompleteLiteralTimeRange.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardPanelSumoSearchPanelTimeRangeCompleteLiteralTimeRange.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 range_name: str):
        pulumi.set(__self__, "range_name", range_name)

    @property
    @pulumi.getter(name="rangeName")
    def range_name(self) -> str:
        return pulumi.get(self, "range_name")


@pulumi.output_type
class DashboardPanelTextPanel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "keepVisualSettingsConsistentWithParent":
            suggest = "keep_visual_settings_consistent_with_parent"
        elif key == "visualSettings":
            suggest = "visual_settings"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardPanelTextPanel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardPanelTextPanel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardPanelTextPanel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 key: str,
                 id: Optional[str] = None,
                 keep_visual_settings_consistent_with_parent: Optional[bool] = None,
                 text: Optional[str] = None,
                 title: Optional[str] = None,
                 visual_settings: Optional[str] = None):
        pulumi.set(__self__, "key", key)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if keep_visual_settings_consistent_with_parent is not None:
            pulumi.set(__self__, "keep_visual_settings_consistent_with_parent", keep_visual_settings_consistent_with_parent)
        if text is not None:
            pulumi.set(__self__, "text", text)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if visual_settings is not None:
            pulumi.set(__self__, "visual_settings", visual_settings)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="keepVisualSettingsConsistentWithParent")
    def keep_visual_settings_consistent_with_parent(self) -> Optional[bool]:
        return pulumi.get(self, "keep_visual_settings_consistent_with_parent")

    @property
    @pulumi.getter
    def text(self) -> Optional[str]:
        return pulumi.get(self, "text")

    @property
    @pulumi.getter
    def title(self) -> Optional[str]:
        return pulumi.get(self, "title")

    @property
    @pulumi.getter(name="visualSettings")
    def visual_settings(self) -> Optional[str]:
        return pulumi.get(self, "visual_settings")


@pulumi.output_type
class DashboardTimeRange(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "beginBoundedTimeRange":
            suggest = "begin_bounded_time_range"
        elif key == "completeLiteralTimeRange":
            suggest = "complete_literal_time_range"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardTimeRange. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardTimeRange.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardTimeRange.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 begin_bounded_time_range: Optional['outputs.DashboardTimeRangeBeginBoundedTimeRange'] = None,
                 complete_literal_time_range: Optional['outputs.DashboardTimeRangeCompleteLiteralTimeRange'] = None):
        if begin_bounded_time_range is not None:
            pulumi.set(__self__, "begin_bounded_time_range", begin_bounded_time_range)
        if complete_literal_time_range is not None:
            pulumi.set(__self__, "complete_literal_time_range", complete_literal_time_range)

    @property
    @pulumi.getter(name="beginBoundedTimeRange")
    def begin_bounded_time_range(self) -> Optional['outputs.DashboardTimeRangeBeginBoundedTimeRange']:
        return pulumi.get(self, "begin_bounded_time_range")

    @property
    @pulumi.getter(name="completeLiteralTimeRange")
    def complete_literal_time_range(self) -> Optional['outputs.DashboardTimeRangeCompleteLiteralTimeRange']:
        return pulumi.get(self, "complete_literal_time_range")


@pulumi.output_type
class DashboardTimeRangeBeginBoundedTimeRange(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "from":
            suggest = "from_"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardTimeRangeBeginBoundedTimeRange. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardTimeRangeBeginBoundedTimeRange.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardTimeRangeBeginBoundedTimeRange.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 from_: 'outputs.DashboardTimeRangeBeginBoundedTimeRangeFrom',
                 to: Optional['outputs.DashboardTimeRangeBeginBoundedTimeRangeTo'] = None):
        pulumi.set(__self__, "from_", from_)
        if to is not None:
            pulumi.set(__self__, "to", to)

    @property
    @pulumi.getter(name="from")
    def from_(self) -> 'outputs.DashboardTimeRangeBeginBoundedTimeRangeFrom':
        return pulumi.get(self, "from_")

    @property
    @pulumi.getter
    def to(self) -> Optional['outputs.DashboardTimeRangeBeginBoundedTimeRangeTo']:
        return pulumi.get(self, "to")


@pulumi.output_type
class DashboardTimeRangeBeginBoundedTimeRangeFrom(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "epochTimeRange":
            suggest = "epoch_time_range"
        elif key == "iso8601TimeRange":
            suggest = "iso8601_time_range"
        elif key == "literalTimeRange":
            suggest = "literal_time_range"
        elif key == "relativeTimeRange":
            suggest = "relative_time_range"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardTimeRangeBeginBoundedTimeRangeFrom. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardTimeRangeBeginBoundedTimeRangeFrom.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardTimeRangeBeginBoundedTimeRangeFrom.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 epoch_time_range: Optional['outputs.DashboardTimeRangeBeginBoundedTimeRangeFromEpochTimeRange'] = None,
                 iso8601_time_range: Optional['outputs.DashboardTimeRangeBeginBoundedTimeRangeFromIso8601TimeRange'] = None,
                 literal_time_range: Optional['outputs.DashboardTimeRangeBeginBoundedTimeRangeFromLiteralTimeRange'] = None,
                 relative_time_range: Optional['outputs.DashboardTimeRangeBeginBoundedTimeRangeFromRelativeTimeRange'] = None):
        if epoch_time_range is not None:
            pulumi.set(__self__, "epoch_time_range", epoch_time_range)
        if iso8601_time_range is not None:
            pulumi.set(__self__, "iso8601_time_range", iso8601_time_range)
        if literal_time_range is not None:
            pulumi.set(__self__, "literal_time_range", literal_time_range)
        if relative_time_range is not None:
            pulumi.set(__self__, "relative_time_range", relative_time_range)

    @property
    @pulumi.getter(name="epochTimeRange")
    def epoch_time_range(self) -> Optional['outputs.DashboardTimeRangeBeginBoundedTimeRangeFromEpochTimeRange']:
        return pulumi.get(self, "epoch_time_range")

    @property
    @pulumi.getter(name="iso8601TimeRange")
    def iso8601_time_range(self) -> Optional['outputs.DashboardTimeRangeBeginBoundedTimeRangeFromIso8601TimeRange']:
        return pulumi.get(self, "iso8601_time_range")

    @property
    @pulumi.getter(name="literalTimeRange")
    def literal_time_range(self) -> Optional['outputs.DashboardTimeRangeBeginBoundedTimeRangeFromLiteralTimeRange']:
        return pulumi.get(self, "literal_time_range")

    @property
    @pulumi.getter(name="relativeTimeRange")
    def relative_time_range(self) -> Optional['outputs.DashboardTimeRangeBeginBoundedTimeRangeFromRelativeTimeRange']:
        return pulumi.get(self, "relative_time_range")


@pulumi.output_type
class DashboardTimeRangeBeginBoundedTimeRangeFromEpochTimeRange(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "epochMillis":
            suggest = "epoch_millis"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardTimeRangeBeginBoundedTimeRangeFromEpochTimeRange. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardTimeRangeBeginBoundedTimeRangeFromEpochTimeRange.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardTimeRangeBeginBoundedTimeRangeFromEpochTimeRange.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 epoch_millis: int):
        pulumi.set(__self__, "epoch_millis", epoch_millis)

    @property
    @pulumi.getter(name="epochMillis")
    def epoch_millis(self) -> int:
        return pulumi.get(self, "epoch_millis")


@pulumi.output_type
class DashboardTimeRangeBeginBoundedTimeRangeFromIso8601TimeRange(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "iso8601Time":
            suggest = "iso8601_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardTimeRangeBeginBoundedTimeRangeFromIso8601TimeRange. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardTimeRangeBeginBoundedTimeRangeFromIso8601TimeRange.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardTimeRangeBeginBoundedTimeRangeFromIso8601TimeRange.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 iso8601_time: str):
        pulumi.set(__self__, "iso8601_time", iso8601_time)

    @property
    @pulumi.getter(name="iso8601Time")
    def iso8601_time(self) -> str:
        return pulumi.get(self, "iso8601_time")


@pulumi.output_type
class DashboardTimeRangeBeginBoundedTimeRangeFromLiteralTimeRange(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "rangeName":
            suggest = "range_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardTimeRangeBeginBoundedTimeRangeFromLiteralTimeRange. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardTimeRangeBeginBoundedTimeRangeFromLiteralTimeRange.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardTimeRangeBeginBoundedTimeRangeFromLiteralTimeRange.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 range_name: str):
        pulumi.set(__self__, "range_name", range_name)

    @property
    @pulumi.getter(name="rangeName")
    def range_name(self) -> str:
        return pulumi.get(self, "range_name")


@pulumi.output_type
class DashboardTimeRangeBeginBoundedTimeRangeFromRelativeTimeRange(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "relativeTime":
            suggest = "relative_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardTimeRangeBeginBoundedTimeRangeFromRelativeTimeRange. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardTimeRangeBeginBoundedTimeRangeFromRelativeTimeRange.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardTimeRangeBeginBoundedTimeRangeFromRelativeTimeRange.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 relative_time: str):
        pulumi.set(__self__, "relative_time", relative_time)

    @property
    @pulumi.getter(name="relativeTime")
    def relative_time(self) -> str:
        return pulumi.get(self, "relative_time")


@pulumi.output_type
class DashboardTimeRangeBeginBoundedTimeRangeTo(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "epochTimeRange":
            suggest = "epoch_time_range"
        elif key == "iso8601TimeRange":
            suggest = "iso8601_time_range"
        elif key == "literalTimeRange":
            suggest = "literal_time_range"
        elif key == "relativeTimeRange":
            suggest = "relative_time_range"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardTimeRangeBeginBoundedTimeRangeTo. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardTimeRangeBeginBoundedTimeRangeTo.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardTimeRangeBeginBoundedTimeRangeTo.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 epoch_time_range: Optional['outputs.DashboardTimeRangeBeginBoundedTimeRangeToEpochTimeRange'] = None,
                 iso8601_time_range: Optional['outputs.DashboardTimeRangeBeginBoundedTimeRangeToIso8601TimeRange'] = None,
                 literal_time_range: Optional['outputs.DashboardTimeRangeBeginBoundedTimeRangeToLiteralTimeRange'] = None,
                 relative_time_range: Optional['outputs.DashboardTimeRangeBeginBoundedTimeRangeToRelativeTimeRange'] = None):
        if epoch_time_range is not None:
            pulumi.set(__self__, "epoch_time_range", epoch_time_range)
        if iso8601_time_range is not None:
            pulumi.set(__self__, "iso8601_time_range", iso8601_time_range)
        if literal_time_range is not None:
            pulumi.set(__self__, "literal_time_range", literal_time_range)
        if relative_time_range is not None:
            pulumi.set(__self__, "relative_time_range", relative_time_range)

    @property
    @pulumi.getter(name="epochTimeRange")
    def epoch_time_range(self) -> Optional['outputs.DashboardTimeRangeBeginBoundedTimeRangeToEpochTimeRange']:
        return pulumi.get(self, "epoch_time_range")

    @property
    @pulumi.getter(name="iso8601TimeRange")
    def iso8601_time_range(self) -> Optional['outputs.DashboardTimeRangeBeginBoundedTimeRangeToIso8601TimeRange']:
        return pulumi.get(self, "iso8601_time_range")

    @property
    @pulumi.getter(name="literalTimeRange")
    def literal_time_range(self) -> Optional['outputs.DashboardTimeRangeBeginBoundedTimeRangeToLiteralTimeRange']:
        return pulumi.get(self, "literal_time_range")

    @property
    @pulumi.getter(name="relativeTimeRange")
    def relative_time_range(self) -> Optional['outputs.DashboardTimeRangeBeginBoundedTimeRangeToRelativeTimeRange']:
        return pulumi.get(self, "relative_time_range")


@pulumi.output_type
class DashboardTimeRangeBeginBoundedTimeRangeToEpochTimeRange(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "epochMillis":
            suggest = "epoch_millis"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardTimeRangeBeginBoundedTimeRangeToEpochTimeRange. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardTimeRangeBeginBoundedTimeRangeToEpochTimeRange.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardTimeRangeBeginBoundedTimeRangeToEpochTimeRange.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 epoch_millis: int):
        pulumi.set(__self__, "epoch_millis", epoch_millis)

    @property
    @pulumi.getter(name="epochMillis")
    def epoch_millis(self) -> int:
        return pulumi.get(self, "epoch_millis")


@pulumi.output_type
class DashboardTimeRangeBeginBoundedTimeRangeToIso8601TimeRange(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "iso8601Time":
            suggest = "iso8601_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardTimeRangeBeginBoundedTimeRangeToIso8601TimeRange. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardTimeRangeBeginBoundedTimeRangeToIso8601TimeRange.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardTimeRangeBeginBoundedTimeRangeToIso8601TimeRange.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 iso8601_time: str):
        pulumi.set(__self__, "iso8601_time", iso8601_time)

    @property
    @pulumi.getter(name="iso8601Time")
    def iso8601_time(self) -> str:
        return pulumi.get(self, "iso8601_time")


@pulumi.output_type
class DashboardTimeRangeBeginBoundedTimeRangeToLiteralTimeRange(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "rangeName":
            suggest = "range_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardTimeRangeBeginBoundedTimeRangeToLiteralTimeRange. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardTimeRangeBeginBoundedTimeRangeToLiteralTimeRange.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardTimeRangeBeginBoundedTimeRangeToLiteralTimeRange.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 range_name: str):
        pulumi.set(__self__, "range_name", range_name)

    @property
    @pulumi.getter(name="rangeName")
    def range_name(self) -> str:
        return pulumi.get(self, "range_name")


@pulumi.output_type
class DashboardTimeRangeBeginBoundedTimeRangeToRelativeTimeRange(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "relativeTime":
            suggest = "relative_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardTimeRangeBeginBoundedTimeRangeToRelativeTimeRange. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardTimeRangeBeginBoundedTimeRangeToRelativeTimeRange.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardTimeRangeBeginBoundedTimeRangeToRelativeTimeRange.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 relative_time: str):
        pulumi.set(__self__, "relative_time", relative_time)

    @property
    @pulumi.getter(name="relativeTime")
    def relative_time(self) -> str:
        return pulumi.get(self, "relative_time")


@pulumi.output_type
class DashboardTimeRangeCompleteLiteralTimeRange(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "rangeName":
            suggest = "range_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardTimeRangeCompleteLiteralTimeRange. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardTimeRangeCompleteLiteralTimeRange.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardTimeRangeCompleteLiteralTimeRange.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 range_name: str):
        pulumi.set(__self__, "range_name", range_name)

    @property
    @pulumi.getter(name="rangeName")
    def range_name(self) -> str:
        return pulumi.get(self, "range_name")


@pulumi.output_type
class DashboardTopologyLabelMap(dict):
    def __init__(__self__, *,
                 datas: Sequence['outputs.DashboardTopologyLabelMapData']):
        pulumi.set(__self__, "datas", datas)

    @property
    @pulumi.getter
    def datas(self) -> Sequence['outputs.DashboardTopologyLabelMapData']:
        return pulumi.get(self, "datas")


@pulumi.output_type
class DashboardTopologyLabelMapData(dict):
    def __init__(__self__, *,
                 label: str,
                 values: Sequence[str]):
        pulumi.set(__self__, "label", label)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def label(self) -> str:
        return pulumi.get(self, "label")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")


@pulumi.output_type
class DashboardVariable(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sourceDefinition":
            suggest = "source_definition"
        elif key == "allowMultiSelect":
            suggest = "allow_multi_select"
        elif key == "defaultValue":
            suggest = "default_value"
        elif key == "displayName":
            suggest = "display_name"
        elif key == "hideFromUi":
            suggest = "hide_from_ui"
        elif key == "includeAllOption":
            suggest = "include_all_option"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardVariable. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardVariable.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardVariable.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 source_definition: 'outputs.DashboardVariableSourceDefinition',
                 allow_multi_select: Optional[bool] = None,
                 default_value: Optional[str] = None,
                 display_name: Optional[str] = None,
                 hide_from_ui: Optional[bool] = None,
                 id: Optional[str] = None,
                 include_all_option: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "source_definition", source_definition)
        if allow_multi_select is not None:
            pulumi.set(__self__, "allow_multi_select", allow_multi_select)
        if default_value is not None:
            pulumi.set(__self__, "default_value", default_value)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if hide_from_ui is not None:
            pulumi.set(__self__, "hide_from_ui", hide_from_ui)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if include_all_option is not None:
            pulumi.set(__self__, "include_all_option", include_all_option)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="sourceDefinition")
    def source_definition(self) -> 'outputs.DashboardVariableSourceDefinition':
        return pulumi.get(self, "source_definition")

    @property
    @pulumi.getter(name="allowMultiSelect")
    def allow_multi_select(self) -> Optional[bool]:
        return pulumi.get(self, "allow_multi_select")

    @property
    @pulumi.getter(name="defaultValue")
    def default_value(self) -> Optional[str]:
        return pulumi.get(self, "default_value")

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[str]:
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter(name="hideFromUi")
    def hide_from_ui(self) -> Optional[bool]:
        return pulumi.get(self, "hide_from_ui")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="includeAllOption")
    def include_all_option(self) -> Optional[bool]:
        return pulumi.get(self, "include_all_option")


@pulumi.output_type
class DashboardVariableSourceDefinition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "csvVariableSourceDefinition":
            suggest = "csv_variable_source_definition"
        elif key == "logQueryVariableSourceDefinition":
            suggest = "log_query_variable_source_definition"
        elif key == "metadataVariableSourceDefinition":
            suggest = "metadata_variable_source_definition"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardVariableSourceDefinition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardVariableSourceDefinition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardVariableSourceDefinition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 csv_variable_source_definition: Optional['outputs.DashboardVariableSourceDefinitionCsvVariableSourceDefinition'] = None,
                 log_query_variable_source_definition: Optional['outputs.DashboardVariableSourceDefinitionLogQueryVariableSourceDefinition'] = None,
                 metadata_variable_source_definition: Optional['outputs.DashboardVariableSourceDefinitionMetadataVariableSourceDefinition'] = None):
        if csv_variable_source_definition is not None:
            pulumi.set(__self__, "csv_variable_source_definition", csv_variable_source_definition)
        if log_query_variable_source_definition is not None:
            pulumi.set(__self__, "log_query_variable_source_definition", log_query_variable_source_definition)
        if metadata_variable_source_definition is not None:
            pulumi.set(__self__, "metadata_variable_source_definition", metadata_variable_source_definition)

    @property
    @pulumi.getter(name="csvVariableSourceDefinition")
    def csv_variable_source_definition(self) -> Optional['outputs.DashboardVariableSourceDefinitionCsvVariableSourceDefinition']:
        return pulumi.get(self, "csv_variable_source_definition")

    @property
    @pulumi.getter(name="logQueryVariableSourceDefinition")
    def log_query_variable_source_definition(self) -> Optional['outputs.DashboardVariableSourceDefinitionLogQueryVariableSourceDefinition']:
        return pulumi.get(self, "log_query_variable_source_definition")

    @property
    @pulumi.getter(name="metadataVariableSourceDefinition")
    def metadata_variable_source_definition(self) -> Optional['outputs.DashboardVariableSourceDefinitionMetadataVariableSourceDefinition']:
        return pulumi.get(self, "metadata_variable_source_definition")


@pulumi.output_type
class DashboardVariableSourceDefinitionCsvVariableSourceDefinition(dict):
    def __init__(__self__, *,
                 values: str):
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def values(self) -> str:
        return pulumi.get(self, "values")


@pulumi.output_type
class DashboardVariableSourceDefinitionLogQueryVariableSourceDefinition(dict):
    def __init__(__self__, *,
                 field: str,
                 query: str):
        pulumi.set(__self__, "field", field)
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def field(self) -> str:
        return pulumi.get(self, "field")

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")


@pulumi.output_type
class DashboardVariableSourceDefinitionMetadataVariableSourceDefinition(dict):
    def __init__(__self__, *,
                 filter: str,
                 key: str):
        pulumi.set(__self__, "filter", filter)
        pulumi.set(__self__, "key", key)

    @property
    @pulumi.getter
    def filter(self) -> str:
        return pulumi.get(self, "filter")

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")


@pulumi.output_type
class ElbSourceAuthentication(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessKey":
            suggest = "access_key"
        elif key == "roleArn":
            suggest = "role_arn"
        elif key == "secretKey":
            suggest = "secret_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ElbSourceAuthentication. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ElbSourceAuthentication.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ElbSourceAuthentication.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: str,
                 access_key: Optional[str] = None,
                 role_arn: Optional[str] = None,
                 secret_key: Optional[str] = None):
        pulumi.set(__self__, "type", type)
        if access_key is not None:
            pulumi.set(__self__, "access_key", access_key)
        if role_arn is not None:
            pulumi.set(__self__, "role_arn", role_arn)
        if secret_key is not None:
            pulumi.set(__self__, "secret_key", secret_key)

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="accessKey")
    def access_key(self) -> Optional[str]:
        return pulumi.get(self, "access_key")

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> Optional[str]:
        return pulumi.get(self, "role_arn")

    @property
    @pulumi.getter(name="secretKey")
    def secret_key(self) -> Optional[str]:
        return pulumi.get(self, "secret_key")


@pulumi.output_type
class ElbSourceDefaultDateFormat(dict):
    def __init__(__self__, *,
                 format: str,
                 locator: Optional[str] = None):
        pulumi.set(__self__, "format", format)
        if locator is not None:
            pulumi.set(__self__, "locator", locator)

    @property
    @pulumi.getter
    def format(self) -> str:
        return pulumi.get(self, "format")

    @property
    @pulumi.getter
    def locator(self) -> Optional[str]:
        return pulumi.get(self, "locator")


@pulumi.output_type
class ElbSourceFilter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "filterType":
            suggest = "filter_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ElbSourceFilter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ElbSourceFilter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ElbSourceFilter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 filter_type: str,
                 name: str,
                 regexp: str,
                 mask: Optional[str] = None):
        pulumi.set(__self__, "filter_type", filter_type)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "regexp", regexp)
        if mask is not None:
            pulumi.set(__self__, "mask", mask)

    @property
    @pulumi.getter(name="filterType")
    def filter_type(self) -> str:
        return pulumi.get(self, "filter_type")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def regexp(self) -> str:
        return pulumi.get(self, "regexp")

    @property
    @pulumi.getter
    def mask(self) -> Optional[str]:
        return pulumi.get(self, "mask")


@pulumi.output_type
class ElbSourcePath(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bucketName":
            suggest = "bucket_name"
        elif key == "limitToNamespaces":
            suggest = "limit_to_namespaces"
        elif key == "limitToRegions":
            suggest = "limit_to_regions"
        elif key == "pathExpression":
            suggest = "path_expression"
        elif key == "tagFilters":
            suggest = "tag_filters"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ElbSourcePath. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ElbSourcePath.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ElbSourcePath.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: str,
                 bucket_name: Optional[str] = None,
                 limit_to_namespaces: Optional[Sequence[str]] = None,
                 limit_to_regions: Optional[Sequence[str]] = None,
                 path_expression: Optional[str] = None,
                 tag_filters: Optional[Sequence['outputs.ElbSourcePathTagFilter']] = None):
        pulumi.set(__self__, "type", type)
        if bucket_name is not None:
            pulumi.set(__self__, "bucket_name", bucket_name)
        if limit_to_namespaces is not None:
            pulumi.set(__self__, "limit_to_namespaces", limit_to_namespaces)
        if limit_to_regions is not None:
            pulumi.set(__self__, "limit_to_regions", limit_to_regions)
        if path_expression is not None:
            pulumi.set(__self__, "path_expression", path_expression)
        if tag_filters is not None:
            pulumi.set(__self__, "tag_filters", tag_filters)

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="bucketName")
    def bucket_name(self) -> Optional[str]:
        return pulumi.get(self, "bucket_name")

    @property
    @pulumi.getter(name="limitToNamespaces")
    def limit_to_namespaces(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "limit_to_namespaces")

    @property
    @pulumi.getter(name="limitToRegions")
    def limit_to_regions(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "limit_to_regions")

    @property
    @pulumi.getter(name="pathExpression")
    def path_expression(self) -> Optional[str]:
        return pulumi.get(self, "path_expression")

    @property
    @pulumi.getter(name="tagFilters")
    def tag_filters(self) -> Optional[Sequence['outputs.ElbSourcePathTagFilter']]:
        return pulumi.get(self, "tag_filters")


@pulumi.output_type
class ElbSourcePathTagFilter(dict):
    def __init__(__self__, *,
                 namespace: Optional[str] = None,
                 tags: Optional[Sequence[str]] = None,
                 type: Optional[str] = None):
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def namespace(self) -> Optional[str]:
        return pulumi.get(self, "namespace")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")


@pulumi.output_type
class GcpSourceAuthentication(dict):
    def __init__(__self__, *,
                 type: Optional[str] = None):
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")


@pulumi.output_type
class GcpSourceDefaultDateFormat(dict):
    def __init__(__self__, *,
                 format: str,
                 locator: Optional[str] = None):
        pulumi.set(__self__, "format", format)
        if locator is not None:
            pulumi.set(__self__, "locator", locator)

    @property
    @pulumi.getter
    def format(self) -> str:
        return pulumi.get(self, "format")

    @property
    @pulumi.getter
    def locator(self) -> Optional[str]:
        return pulumi.get(self, "locator")


@pulumi.output_type
class GcpSourceFilter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "filterType":
            suggest = "filter_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GcpSourceFilter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GcpSourceFilter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GcpSourceFilter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 filter_type: str,
                 name: str,
                 regexp: str,
                 mask: Optional[str] = None):
        pulumi.set(__self__, "filter_type", filter_type)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "regexp", regexp)
        if mask is not None:
            pulumi.set(__self__, "mask", mask)

    @property
    @pulumi.getter(name="filterType")
    def filter_type(self) -> str:
        return pulumi.get(self, "filter_type")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def regexp(self) -> str:
        return pulumi.get(self, "regexp")

    @property
    @pulumi.getter
    def mask(self) -> Optional[str]:
        return pulumi.get(self, "mask")


@pulumi.output_type
class GcpSourcePath(dict):
    def __init__(__self__, *,
                 type: Optional[str] = None):
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")


@pulumi.output_type
class HttpSourceDefaultDateFormat(dict):
    def __init__(__self__, *,
                 format: str,
                 locator: Optional[str] = None):
        pulumi.set(__self__, "format", format)
        if locator is not None:
            pulumi.set(__self__, "locator", locator)

    @property
    @pulumi.getter
    def format(self) -> str:
        return pulumi.get(self, "format")

    @property
    @pulumi.getter
    def locator(self) -> Optional[str]:
        return pulumi.get(self, "locator")


@pulumi.output_type
class HttpSourceFilter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "filterType":
            suggest = "filter_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HttpSourceFilter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HttpSourceFilter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HttpSourceFilter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 filter_type: str,
                 name: str,
                 regexp: str,
                 mask: Optional[str] = None):
        pulumi.set(__self__, "filter_type", filter_type)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "regexp", regexp)
        if mask is not None:
            pulumi.set(__self__, "mask", mask)

    @property
    @pulumi.getter(name="filterType")
    def filter_type(self) -> str:
        return pulumi.get(self, "filter_type")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def regexp(self) -> str:
        return pulumi.get(self, "regexp")

    @property
    @pulumi.getter
    def mask(self) -> Optional[str]:
        return pulumi.get(self, "mask")


@pulumi.output_type
class KinesisMetricsSourceAuthentication(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessKey":
            suggest = "access_key"
        elif key == "roleArn":
            suggest = "role_arn"
        elif key == "secretKey":
            suggest = "secret_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KinesisMetricsSourceAuthentication. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KinesisMetricsSourceAuthentication.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KinesisMetricsSourceAuthentication.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: str,
                 access_key: Optional[str] = None,
                 role_arn: Optional[str] = None,
                 secret_key: Optional[str] = None):
        pulumi.set(__self__, "type", type)
        if access_key is not None:
            pulumi.set(__self__, "access_key", access_key)
        if role_arn is not None:
            pulumi.set(__self__, "role_arn", role_arn)
        if secret_key is not None:
            pulumi.set(__self__, "secret_key", secret_key)

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="accessKey")
    def access_key(self) -> Optional[str]:
        return pulumi.get(self, "access_key")

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> Optional[str]:
        return pulumi.get(self, "role_arn")

    @property
    @pulumi.getter(name="secretKey")
    def secret_key(self) -> Optional[str]:
        return pulumi.get(self, "secret_key")


@pulumi.output_type
class KinesisMetricsSourceDefaultDateFormat(dict):
    def __init__(__self__, *,
                 format: str,
                 locator: Optional[str] = None):
        pulumi.set(__self__, "format", format)
        if locator is not None:
            pulumi.set(__self__, "locator", locator)

    @property
    @pulumi.getter
    def format(self) -> str:
        return pulumi.get(self, "format")

    @property
    @pulumi.getter
    def locator(self) -> Optional[str]:
        return pulumi.get(self, "locator")


@pulumi.output_type
class KinesisMetricsSourceFilter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "filterType":
            suggest = "filter_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KinesisMetricsSourceFilter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KinesisMetricsSourceFilter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KinesisMetricsSourceFilter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 filter_type: str,
                 name: str,
                 regexp: str,
                 mask: Optional[str] = None):
        pulumi.set(__self__, "filter_type", filter_type)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "regexp", regexp)
        if mask is not None:
            pulumi.set(__self__, "mask", mask)

    @property
    @pulumi.getter(name="filterType")
    def filter_type(self) -> str:
        return pulumi.get(self, "filter_type")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def regexp(self) -> str:
        return pulumi.get(self, "regexp")

    @property
    @pulumi.getter
    def mask(self) -> Optional[str]:
        return pulumi.get(self, "mask")


@pulumi.output_type
class KinesisMetricsSourcePath(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "tagFilters":
            suggest = "tag_filters"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KinesisMetricsSourcePath. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KinesisMetricsSourcePath.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KinesisMetricsSourcePath.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: str,
                 tag_filters: Optional[Sequence['outputs.KinesisMetricsSourcePathTagFilter']] = None):
        pulumi.set(__self__, "type", type)
        if tag_filters is not None:
            pulumi.set(__self__, "tag_filters", tag_filters)

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="tagFilters")
    def tag_filters(self) -> Optional[Sequence['outputs.KinesisMetricsSourcePathTagFilter']]:
        return pulumi.get(self, "tag_filters")


@pulumi.output_type
class KinesisMetricsSourcePathTagFilter(dict):
    def __init__(__self__, *,
                 namespace: Optional[str] = None,
                 tags: Optional[Sequence[str]] = None,
                 type: Optional[str] = None):
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def namespace(self) -> Optional[str]:
        return pulumi.get(self, "namespace")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")


@pulumi.output_type
class LookupTableField(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fieldName":
            suggest = "field_name"
        elif key == "fieldType":
            suggest = "field_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LookupTableField. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LookupTableField.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LookupTableField.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 field_name: str,
                 field_type: str):
        pulumi.set(__self__, "field_name", field_name)
        pulumi.set(__self__, "field_type", field_type)

    @property
    @pulumi.getter(name="fieldName")
    def field_name(self) -> str:
        return pulumi.get(self, "field_name")

    @property
    @pulumi.getter(name="fieldType")
    def field_type(self) -> str:
        return pulumi.get(self, "field_type")


@pulumi.output_type
class MetadataSourceAuthentication(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessKey":
            suggest = "access_key"
        elif key == "roleArn":
            suggest = "role_arn"
        elif key == "secretKey":
            suggest = "secret_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MetadataSourceAuthentication. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MetadataSourceAuthentication.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MetadataSourceAuthentication.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: str,
                 access_key: Optional[str] = None,
                 role_arn: Optional[str] = None,
                 secret_key: Optional[str] = None):
        pulumi.set(__self__, "type", type)
        if access_key is not None:
            pulumi.set(__self__, "access_key", access_key)
        if role_arn is not None:
            pulumi.set(__self__, "role_arn", role_arn)
        if secret_key is not None:
            pulumi.set(__self__, "secret_key", secret_key)

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="accessKey")
    def access_key(self) -> Optional[str]:
        return pulumi.get(self, "access_key")

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> Optional[str]:
        return pulumi.get(self, "role_arn")

    @property
    @pulumi.getter(name="secretKey")
    def secret_key(self) -> Optional[str]:
        return pulumi.get(self, "secret_key")


@pulumi.output_type
class MetadataSourceDefaultDateFormat(dict):
    def __init__(__self__, *,
                 format: str,
                 locator: Optional[str] = None):
        pulumi.set(__self__, "format", format)
        if locator is not None:
            pulumi.set(__self__, "locator", locator)

    @property
    @pulumi.getter
    def format(self) -> str:
        return pulumi.get(self, "format")

    @property
    @pulumi.getter
    def locator(self) -> Optional[str]:
        return pulumi.get(self, "locator")


@pulumi.output_type
class MetadataSourceFilter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "filterType":
            suggest = "filter_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MetadataSourceFilter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MetadataSourceFilter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MetadataSourceFilter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 filter_type: str,
                 name: str,
                 regexp: str,
                 mask: Optional[str] = None):
        pulumi.set(__self__, "filter_type", filter_type)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "regexp", regexp)
        if mask is not None:
            pulumi.set(__self__, "mask", mask)

    @property
    @pulumi.getter(name="filterType")
    def filter_type(self) -> str:
        return pulumi.get(self, "filter_type")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def regexp(self) -> str:
        return pulumi.get(self, "regexp")

    @property
    @pulumi.getter
    def mask(self) -> Optional[str]:
        return pulumi.get(self, "mask")


@pulumi.output_type
class MetadataSourcePath(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "limitToNamespaces":
            suggest = "limit_to_namespaces"
        elif key == "limitToRegions":
            suggest = "limit_to_regions"
        elif key == "tagFilters":
            suggest = "tag_filters"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MetadataSourcePath. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MetadataSourcePath.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MetadataSourcePath.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: str,
                 limit_to_namespaces: Optional[Sequence[str]] = None,
                 limit_to_regions: Optional[Sequence[str]] = None,
                 tag_filters: Optional[Sequence[str]] = None):
        pulumi.set(__self__, "type", type)
        if limit_to_namespaces is not None:
            pulumi.set(__self__, "limit_to_namespaces", limit_to_namespaces)
        if limit_to_regions is not None:
            pulumi.set(__self__, "limit_to_regions", limit_to_regions)
        if tag_filters is not None:
            pulumi.set(__self__, "tag_filters", tag_filters)

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="limitToNamespaces")
    def limit_to_namespaces(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "limit_to_namespaces")

    @property
    @pulumi.getter(name="limitToRegions")
    def limit_to_regions(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "limit_to_regions")

    @property
    @pulumi.getter(name="tagFilters")
    def tag_filters(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "tag_filters")


@pulumi.output_type
class MonitorNotification(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "runForTriggerTypes":
            suggest = "run_for_trigger_types"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MonitorNotification. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MonitorNotification.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MonitorNotification.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 notification: 'outputs.MonitorNotificationNotification',
                 run_for_trigger_types: Sequence[str]):
        pulumi.set(__self__, "notification", notification)
        pulumi.set(__self__, "run_for_trigger_types", run_for_trigger_types)

    @property
    @pulumi.getter
    def notification(self) -> 'outputs.MonitorNotificationNotification':
        return pulumi.get(self, "notification")

    @property
    @pulumi.getter(name="runForTriggerTypes")
    def run_for_trigger_types(self) -> Sequence[str]:
        return pulumi.get(self, "run_for_trigger_types")


@pulumi.output_type
class MonitorNotificationNotification(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "actionType":
            suggest = "action_type"
        elif key == "connectionId":
            suggest = "connection_id"
        elif key == "connectionType":
            suggest = "connection_type"
        elif key == "messageBody":
            suggest = "message_body"
        elif key == "payloadOverride":
            suggest = "payload_override"
        elif key == "timeZone":
            suggest = "time_zone"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MonitorNotificationNotification. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MonitorNotificationNotification.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MonitorNotificationNotification.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action_type: Optional[str] = None,
                 connection_id: Optional[str] = None,
                 connection_type: Optional[str] = None,
                 message_body: Optional[str] = None,
                 payload_override: Optional[str] = None,
                 recipients: Optional[Sequence[str]] = None,
                 subject: Optional[str] = None,
                 time_zone: Optional[str] = None):
        if action_type is not None:
            pulumi.set(__self__, "action_type", action_type)
        if connection_id is not None:
            pulumi.set(__self__, "connection_id", connection_id)
        if connection_type is not None:
            pulumi.set(__self__, "connection_type", connection_type)
        if message_body is not None:
            pulumi.set(__self__, "message_body", message_body)
        if payload_override is not None:
            pulumi.set(__self__, "payload_override", payload_override)
        if recipients is not None:
            pulumi.set(__self__, "recipients", recipients)
        if subject is not None:
            pulumi.set(__self__, "subject", subject)
        if time_zone is not None:
            pulumi.set(__self__, "time_zone", time_zone)

    @property
    @pulumi.getter(name="actionType")
    def action_type(self) -> Optional[str]:
        return pulumi.get(self, "action_type")

    @property
    @pulumi.getter(name="connectionId")
    def connection_id(self) -> Optional[str]:
        return pulumi.get(self, "connection_id")

    @property
    @pulumi.getter(name="connectionType")
    def connection_type(self) -> Optional[str]:
        return pulumi.get(self, "connection_type")

    @property
    @pulumi.getter(name="messageBody")
    def message_body(self) -> Optional[str]:
        return pulumi.get(self, "message_body")

    @property
    @pulumi.getter(name="payloadOverride")
    def payload_override(self) -> Optional[str]:
        return pulumi.get(self, "payload_override")

    @property
    @pulumi.getter
    def recipients(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "recipients")

    @property
    @pulumi.getter
    def subject(self) -> Optional[str]:
        return pulumi.get(self, "subject")

    @property
    @pulumi.getter(name="timeZone")
    def time_zone(self) -> Optional[str]:
        return pulumi.get(self, "time_zone")


@pulumi.output_type
class MonitorQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "rowId":
            suggest = "row_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MonitorQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MonitorQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MonitorQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 query: str,
                 row_id: str):
        pulumi.set(__self__, "query", query)
        pulumi.set(__self__, "row_id", row_id)

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")

    @property
    @pulumi.getter(name="rowId")
    def row_id(self) -> str:
        return pulumi.get(self, "row_id")


@pulumi.output_type
class MonitorTrigger(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "detectionMethod":
            suggest = "detection_method"
        elif key == "occurrenceType":
            suggest = "occurrence_type"
        elif key == "thresholdType":
            suggest = "threshold_type"
        elif key == "timeRange":
            suggest = "time_range"
        elif key == "triggerSource":
            suggest = "trigger_source"
        elif key == "triggerType":
            suggest = "trigger_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MonitorTrigger. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MonitorTrigger.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MonitorTrigger.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 detection_method: Optional[str] = None,
                 occurrence_type: Optional[str] = None,
                 threshold: Optional[float] = None,
                 threshold_type: Optional[str] = None,
                 time_range: Optional[str] = None,
                 trigger_source: Optional[str] = None,
                 trigger_type: Optional[str] = None):
        if detection_method is not None:
            pulumi.set(__self__, "detection_method", detection_method)
        if occurrence_type is not None:
            pulumi.set(__self__, "occurrence_type", occurrence_type)
        if threshold is not None:
            pulumi.set(__self__, "threshold", threshold)
        if threshold_type is not None:
            pulumi.set(__self__, "threshold_type", threshold_type)
        if time_range is not None:
            pulumi.set(__self__, "time_range", time_range)
        if trigger_source is not None:
            pulumi.set(__self__, "trigger_source", trigger_source)
        if trigger_type is not None:
            pulumi.set(__self__, "trigger_type", trigger_type)

    @property
    @pulumi.getter(name="detectionMethod")
    def detection_method(self) -> Optional[str]:
        return pulumi.get(self, "detection_method")

    @property
    @pulumi.getter(name="occurrenceType")
    def occurrence_type(self) -> Optional[str]:
        return pulumi.get(self, "occurrence_type")

    @property
    @pulumi.getter
    def threshold(self) -> Optional[float]:
        return pulumi.get(self, "threshold")

    @property
    @pulumi.getter(name="thresholdType")
    def threshold_type(self) -> Optional[str]:
        return pulumi.get(self, "threshold_type")

    @property
    @pulumi.getter(name="timeRange")
    def time_range(self) -> Optional[str]:
        return pulumi.get(self, "time_range")

    @property
    @pulumi.getter(name="triggerSource")
    def trigger_source(self) -> Optional[str]:
        return pulumi.get(self, "trigger_source")

    @property
    @pulumi.getter(name="triggerType")
    def trigger_type(self) -> Optional[str]:
        return pulumi.get(self, "trigger_type")


@pulumi.output_type
class PollingSourceAuthentication(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessKey":
            suggest = "access_key"
        elif key == "roleArn":
            suggest = "role_arn"
        elif key == "secretKey":
            suggest = "secret_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PollingSourceAuthentication. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PollingSourceAuthentication.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PollingSourceAuthentication.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: str,
                 access_key: Optional[str] = None,
                 role_arn: Optional[str] = None,
                 secret_key: Optional[str] = None):
        pulumi.set(__self__, "type", type)
        if access_key is not None:
            pulumi.set(__self__, "access_key", access_key)
        if role_arn is not None:
            pulumi.set(__self__, "role_arn", role_arn)
        if secret_key is not None:
            pulumi.set(__self__, "secret_key", secret_key)

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="accessKey")
    def access_key(self) -> Optional[str]:
        return pulumi.get(self, "access_key")

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> Optional[str]:
        return pulumi.get(self, "role_arn")

    @property
    @pulumi.getter(name="secretKey")
    def secret_key(self) -> Optional[str]:
        return pulumi.get(self, "secret_key")


@pulumi.output_type
class PollingSourceDefaultDateFormat(dict):
    def __init__(__self__, *,
                 format: str,
                 locator: Optional[str] = None):
        pulumi.set(__self__, "format", format)
        if locator is not None:
            pulumi.set(__self__, "locator", locator)

    @property
    @pulumi.getter
    def format(self) -> str:
        return pulumi.get(self, "format")

    @property
    @pulumi.getter
    def locator(self) -> Optional[str]:
        return pulumi.get(self, "locator")


@pulumi.output_type
class PollingSourceFilter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "filterType":
            suggest = "filter_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PollingSourceFilter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PollingSourceFilter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PollingSourceFilter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 filter_type: str,
                 name: str,
                 regexp: str,
                 mask: Optional[str] = None):
        pulumi.set(__self__, "filter_type", filter_type)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "regexp", regexp)
        if mask is not None:
            pulumi.set(__self__, "mask", mask)

    @property
    @pulumi.getter(name="filterType")
    def filter_type(self) -> str:
        return pulumi.get(self, "filter_type")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def regexp(self) -> str:
        return pulumi.get(self, "regexp")

    @property
    @pulumi.getter
    def mask(self) -> Optional[str]:
        return pulumi.get(self, "mask")


@pulumi.output_type
class PollingSourcePath(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bucketName":
            suggest = "bucket_name"
        elif key == "limitToNamespaces":
            suggest = "limit_to_namespaces"
        elif key == "limitToRegions":
            suggest = "limit_to_regions"
        elif key == "pathExpression":
            suggest = "path_expression"
        elif key == "tagFilters":
            suggest = "tag_filters"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PollingSourcePath. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PollingSourcePath.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PollingSourcePath.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: str,
                 bucket_name: Optional[str] = None,
                 limit_to_namespaces: Optional[Sequence[str]] = None,
                 limit_to_regions: Optional[Sequence[str]] = None,
                 path_expression: Optional[str] = None,
                 tag_filters: Optional[Sequence['outputs.PollingSourcePathTagFilter']] = None):
        pulumi.set(__self__, "type", type)
        if bucket_name is not None:
            pulumi.set(__self__, "bucket_name", bucket_name)
        if limit_to_namespaces is not None:
            pulumi.set(__self__, "limit_to_namespaces", limit_to_namespaces)
        if limit_to_regions is not None:
            pulumi.set(__self__, "limit_to_regions", limit_to_regions)
        if path_expression is not None:
            pulumi.set(__self__, "path_expression", path_expression)
        if tag_filters is not None:
            pulumi.set(__self__, "tag_filters", tag_filters)

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="bucketName")
    def bucket_name(self) -> Optional[str]:
        return pulumi.get(self, "bucket_name")

    @property
    @pulumi.getter(name="limitToNamespaces")
    def limit_to_namespaces(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "limit_to_namespaces")

    @property
    @pulumi.getter(name="limitToRegions")
    def limit_to_regions(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "limit_to_regions")

    @property
    @pulumi.getter(name="pathExpression")
    def path_expression(self) -> Optional[str]:
        return pulumi.get(self, "path_expression")

    @property
    @pulumi.getter(name="tagFilters")
    def tag_filters(self) -> Optional[Sequence['outputs.PollingSourcePathTagFilter']]:
        return pulumi.get(self, "tag_filters")


@pulumi.output_type
class PollingSourcePathTagFilter(dict):
    def __init__(__self__, *,
                 namespace: Optional[str] = None,
                 tags: Optional[Sequence[str]] = None,
                 type: Optional[str] = None):
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def namespace(self) -> Optional[str]:
        return pulumi.get(self, "namespace")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")


@pulumi.output_type
class S3AuditSourceAuthentication(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessKey":
            suggest = "access_key"
        elif key == "roleArn":
            suggest = "role_arn"
        elif key == "secretKey":
            suggest = "secret_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in S3AuditSourceAuthentication. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        S3AuditSourceAuthentication.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        S3AuditSourceAuthentication.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: str,
                 access_key: Optional[str] = None,
                 role_arn: Optional[str] = None,
                 secret_key: Optional[str] = None):
        pulumi.set(__self__, "type", type)
        if access_key is not None:
            pulumi.set(__self__, "access_key", access_key)
        if role_arn is not None:
            pulumi.set(__self__, "role_arn", role_arn)
        if secret_key is not None:
            pulumi.set(__self__, "secret_key", secret_key)

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="accessKey")
    def access_key(self) -> Optional[str]:
        return pulumi.get(self, "access_key")

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> Optional[str]:
        return pulumi.get(self, "role_arn")

    @property
    @pulumi.getter(name="secretKey")
    def secret_key(self) -> Optional[str]:
        return pulumi.get(self, "secret_key")


@pulumi.output_type
class S3AuditSourceDefaultDateFormat(dict):
    def __init__(__self__, *,
                 format: str,
                 locator: Optional[str] = None):
        pulumi.set(__self__, "format", format)
        if locator is not None:
            pulumi.set(__self__, "locator", locator)

    @property
    @pulumi.getter
    def format(self) -> str:
        return pulumi.get(self, "format")

    @property
    @pulumi.getter
    def locator(self) -> Optional[str]:
        return pulumi.get(self, "locator")


@pulumi.output_type
class S3AuditSourceFilter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "filterType":
            suggest = "filter_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in S3AuditSourceFilter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        S3AuditSourceFilter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        S3AuditSourceFilter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 filter_type: str,
                 name: str,
                 regexp: str,
                 mask: Optional[str] = None):
        pulumi.set(__self__, "filter_type", filter_type)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "regexp", regexp)
        if mask is not None:
            pulumi.set(__self__, "mask", mask)

    @property
    @pulumi.getter(name="filterType")
    def filter_type(self) -> str:
        return pulumi.get(self, "filter_type")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def regexp(self) -> str:
        return pulumi.get(self, "regexp")

    @property
    @pulumi.getter
    def mask(self) -> Optional[str]:
        return pulumi.get(self, "mask")


@pulumi.output_type
class S3AuditSourcePath(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bucketName":
            suggest = "bucket_name"
        elif key == "limitToNamespaces":
            suggest = "limit_to_namespaces"
        elif key == "limitToRegions":
            suggest = "limit_to_regions"
        elif key == "pathExpression":
            suggest = "path_expression"
        elif key == "tagFilters":
            suggest = "tag_filters"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in S3AuditSourcePath. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        S3AuditSourcePath.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        S3AuditSourcePath.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: str,
                 bucket_name: Optional[str] = None,
                 limit_to_namespaces: Optional[Sequence[str]] = None,
                 limit_to_regions: Optional[Sequence[str]] = None,
                 path_expression: Optional[str] = None,
                 tag_filters: Optional[Sequence['outputs.S3AuditSourcePathTagFilter']] = None):
        pulumi.set(__self__, "type", type)
        if bucket_name is not None:
            pulumi.set(__self__, "bucket_name", bucket_name)
        if limit_to_namespaces is not None:
            pulumi.set(__self__, "limit_to_namespaces", limit_to_namespaces)
        if limit_to_regions is not None:
            pulumi.set(__self__, "limit_to_regions", limit_to_regions)
        if path_expression is not None:
            pulumi.set(__self__, "path_expression", path_expression)
        if tag_filters is not None:
            pulumi.set(__self__, "tag_filters", tag_filters)

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="bucketName")
    def bucket_name(self) -> Optional[str]:
        return pulumi.get(self, "bucket_name")

    @property
    @pulumi.getter(name="limitToNamespaces")
    def limit_to_namespaces(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "limit_to_namespaces")

    @property
    @pulumi.getter(name="limitToRegions")
    def limit_to_regions(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "limit_to_regions")

    @property
    @pulumi.getter(name="pathExpression")
    def path_expression(self) -> Optional[str]:
        return pulumi.get(self, "path_expression")

    @property
    @pulumi.getter(name="tagFilters")
    def tag_filters(self) -> Optional[Sequence['outputs.S3AuditSourcePathTagFilter']]:
        return pulumi.get(self, "tag_filters")


@pulumi.output_type
class S3AuditSourcePathTagFilter(dict):
    def __init__(__self__, *,
                 namespace: Optional[str] = None,
                 tags: Optional[Sequence[str]] = None,
                 type: Optional[str] = None):
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def namespace(self) -> Optional[str]:
        return pulumi.get(self, "namespace")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")


@pulumi.output_type
class S3SourceAuthentication(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessKey":
            suggest = "access_key"
        elif key == "roleArn":
            suggest = "role_arn"
        elif key == "secretKey":
            suggest = "secret_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in S3SourceAuthentication. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        S3SourceAuthentication.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        S3SourceAuthentication.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: str,
                 access_key: Optional[str] = None,
                 role_arn: Optional[str] = None,
                 secret_key: Optional[str] = None):
        pulumi.set(__self__, "type", type)
        if access_key is not None:
            pulumi.set(__self__, "access_key", access_key)
        if role_arn is not None:
            pulumi.set(__self__, "role_arn", role_arn)
        if secret_key is not None:
            pulumi.set(__self__, "secret_key", secret_key)

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="accessKey")
    def access_key(self) -> Optional[str]:
        return pulumi.get(self, "access_key")

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> Optional[str]:
        return pulumi.get(self, "role_arn")

    @property
    @pulumi.getter(name="secretKey")
    def secret_key(self) -> Optional[str]:
        return pulumi.get(self, "secret_key")


@pulumi.output_type
class S3SourceDefaultDateFormat(dict):
    def __init__(__self__, *,
                 format: str,
                 locator: Optional[str] = None):
        pulumi.set(__self__, "format", format)
        if locator is not None:
            pulumi.set(__self__, "locator", locator)

    @property
    @pulumi.getter
    def format(self) -> str:
        return pulumi.get(self, "format")

    @property
    @pulumi.getter
    def locator(self) -> Optional[str]:
        return pulumi.get(self, "locator")


@pulumi.output_type
class S3SourceFilter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "filterType":
            suggest = "filter_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in S3SourceFilter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        S3SourceFilter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        S3SourceFilter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 filter_type: str,
                 name: str,
                 regexp: str,
                 mask: Optional[str] = None):
        pulumi.set(__self__, "filter_type", filter_type)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "regexp", regexp)
        if mask is not None:
            pulumi.set(__self__, "mask", mask)

    @property
    @pulumi.getter(name="filterType")
    def filter_type(self) -> str:
        return pulumi.get(self, "filter_type")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def regexp(self) -> str:
        return pulumi.get(self, "regexp")

    @property
    @pulumi.getter
    def mask(self) -> Optional[str]:
        return pulumi.get(self, "mask")


@pulumi.output_type
class S3SourcePath(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bucketName":
            suggest = "bucket_name"
        elif key == "limitToNamespaces":
            suggest = "limit_to_namespaces"
        elif key == "limitToRegions":
            suggest = "limit_to_regions"
        elif key == "pathExpression":
            suggest = "path_expression"
        elif key == "tagFilters":
            suggest = "tag_filters"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in S3SourcePath. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        S3SourcePath.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        S3SourcePath.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: str,
                 bucket_name: Optional[str] = None,
                 limit_to_namespaces: Optional[Sequence[str]] = None,
                 limit_to_regions: Optional[Sequence[str]] = None,
                 path_expression: Optional[str] = None,
                 tag_filters: Optional[Sequence['outputs.S3SourcePathTagFilter']] = None):
        pulumi.set(__self__, "type", type)
        if bucket_name is not None:
            pulumi.set(__self__, "bucket_name", bucket_name)
        if limit_to_namespaces is not None:
            pulumi.set(__self__, "limit_to_namespaces", limit_to_namespaces)
        if limit_to_regions is not None:
            pulumi.set(__self__, "limit_to_regions", limit_to_regions)
        if path_expression is not None:
            pulumi.set(__self__, "path_expression", path_expression)
        if tag_filters is not None:
            pulumi.set(__self__, "tag_filters", tag_filters)

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="bucketName")
    def bucket_name(self) -> Optional[str]:
        return pulumi.get(self, "bucket_name")

    @property
    @pulumi.getter(name="limitToNamespaces")
    def limit_to_namespaces(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "limit_to_namespaces")

    @property
    @pulumi.getter(name="limitToRegions")
    def limit_to_regions(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "limit_to_regions")

    @property
    @pulumi.getter(name="pathExpression")
    def path_expression(self) -> Optional[str]:
        return pulumi.get(self, "path_expression")

    @property
    @pulumi.getter(name="tagFilters")
    def tag_filters(self) -> Optional[Sequence['outputs.S3SourcePathTagFilter']]:
        return pulumi.get(self, "tag_filters")


@pulumi.output_type
class S3SourcePathTagFilter(dict):
    def __init__(__self__, *,
                 namespace: Optional[str] = None,
                 tags: Optional[Sequence[str]] = None,
                 type: Optional[str] = None):
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def namespace(self) -> Optional[str]:
        return pulumi.get(self, "namespace")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")


@pulumi.output_type
class SamlConfigurationOnDemandProvisioningEnabled(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "onDemandProvisioningRoles":
            suggest = "on_demand_provisioning_roles"
        elif key == "firstNameAttribute":
            suggest = "first_name_attribute"
        elif key == "lastNameAttribute":
            suggest = "last_name_attribute"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SamlConfigurationOnDemandProvisioningEnabled. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SamlConfigurationOnDemandProvisioningEnabled.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SamlConfigurationOnDemandProvisioningEnabled.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 on_demand_provisioning_roles: Sequence[str],
                 first_name_attribute: Optional[str] = None,
                 last_name_attribute: Optional[str] = None):
        pulumi.set(__self__, "on_demand_provisioning_roles", on_demand_provisioning_roles)
        if first_name_attribute is not None:
            pulumi.set(__self__, "first_name_attribute", first_name_attribute)
        if last_name_attribute is not None:
            pulumi.set(__self__, "last_name_attribute", last_name_attribute)

    @property
    @pulumi.getter(name="onDemandProvisioningRoles")
    def on_demand_provisioning_roles(self) -> Sequence[str]:
        return pulumi.get(self, "on_demand_provisioning_roles")

    @property
    @pulumi.getter(name="firstNameAttribute")
    def first_name_attribute(self) -> Optional[str]:
        return pulumi.get(self, "first_name_attribute")

    @property
    @pulumi.getter(name="lastNameAttribute")
    def last_name_attribute(self) -> Optional[str]:
        return pulumi.get(self, "last_name_attribute")


