function M(r,t){if(r==null)return{};var e=j(r,t),n,a;if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(r);for(a=0;a<o.length;a++)n=o[a],!(t.indexOf(n)>=0)&&(!Object.prototype.propertyIsEnumerable.call(r,n)||(e[n]=r[n]))}return e}function j(r,t){if(r==null)return{};var e={},n=Object.keys(r),a,o;for(o=0;o<n.length;o++)a=n[o],!(t.indexOf(a)>=0)&&(e[a]=r[a]);return e}function O(r,t){var e=Object.keys(r);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(r);t&&(n=n.filter(function(a){return Object.getOwnPropertyDescriptor(r,a).enumerable})),e.push.apply(e,n)}return e}function l(r){for(var t=1;t<arguments.length;t++){var e=arguments[t]!=null?arguments[t]:{};t%2?O(Object(e),!0).forEach(function(n){d(r,n,e[n])}):Object.getOwnPropertyDescriptors?Object.defineProperties(r,Object.getOwnPropertyDescriptors(e)):O(Object(e)).forEach(function(n){Object.defineProperty(r,n,Object.getOwnPropertyDescriptor(e,n))})}return r}function d(r,t,e){return t in r?Object.defineProperty(r,t,{value:e,enumerable:!0,configurable:!0,writable:!0}):r[t]=e,r}import{LabelType as f}from"./types.js";import{safeSplit as A}from"../../utils/index.js";import C from"../../../web_modules/lodash/uniq.js";const I="__index__",N="__metadata__",F={NUMBER_MISMATCH:Symbol("NUMBER_MISMATCH"),TENSER_EMPTY:Symbol("TENSER_EMPTY"),METADATA_EMPTY:Symbol("METADATA_EMPTY"),SHAPE_MISMATCH:Symbol("SHAPE_MISMATCH")};export class ParserError extends Error{constructor(t,e,n){super(t);d(this,"code",void 0),d(this,"data",void 0),this.code=e,this.data=n}}d(ParserError,"CODES",F);function S(r,t){return A(r,`
`).map(e=>A(e,"	").map(n=>t?t(n):n)).filter(e=>e.length)}function _(r,t,e){return r.map(n=>{const a=n.length;return a>t?n.slice(0,t):a<t?[...n,...Array.from({length:t-a}).fill(e)]:n})}function T(r){const t=Array.from({length:r}).map((n,a)=>a);let e=r;for(;e;){const n=Math.floor(Math.random()*e);e--;const a=t[e];t[e]=t[n],t[n]=a}return t}function w(r,t,e){const{count:n,dimension:a,vectors:o,metadata:c}=r,s=t?Math.min(n,t):n,i=e?Math.min(a,e):a,m=T(n),h=T(a),b=new Float32Array(s*i),g=[];for(let u=0;u<s;u++){const y=m[u]*a;if(i<a)for(let p=0;p<i;p++)b[u+p]=o[y+h[p]];else b.set(o.subarray(y,y+i),u*i);g.push(c[m[u]])}return l(l({},r),{},{count:s,dimension:i,vectors:b,metadata:g})}function E(r,t){return r.map(e=>e[t])}function P(r){if(!r.length)return[];const t=[],e=r[0].length;for(let n=0;n<e;n++)t.push(E(r,n));return t}function v(r){const t=r.map(Number.parseFloat),e=t.every(Number.isFinite)?f.Value:f.Category;switch(e){case f.Value:return{type:e,minValue:Math.min(...t),maxValue:Math.max(...t)};case f.Category:return{type:e,categories:C(r)};default:return null}}function R(r){if(!r)throw new ParserError("Tenser file is empty",ParserError.CODES.TENSER_EMPTY);const t=[0,0];let e=S(r,Number.parseFloat);t[0]=e.length;const n=Math.min(...e.map(a=>a.length));return t[1]=n,e=_(e,n,0),{rawShape:t,dimension:n,count:e.length,vectors:new Float32Array(e.flat())}}function x(r){if(!r)throw new ParserError("Metadata file is empty",ParserError.CODES.METADATA_EMPTY);let t=S(r);const e=t[0].length;t=_(t,e,"");let n=[];if(e>1){var a;n=((a=t.shift())!==null&&a!==void 0?a:[]).map((c,s)=>l({label:c},v(E(t,s))))}else n=[l({label:N},v(E(t,0)))];return{dimension:e,labels:n,metadata:t}}function D(r,t){if(r){const e=x(r),n=e.metadata.length;if(t!==n)throw new ParserError(`Number of tensors (${t}) do not match the number of lines in metadata (${n}).`,ParserError.CODES.NUMBER_MISMATCH,{vectors:t,metadata:n});return{labels:e.labels,metadata:e.metadata}}return{labels:[{label:I,type:f.Null}],metadata:Array.from({length:t},(e,n)=>[`${n}`])}}export function parseFromString({vectors:r,metadata:t,maxCount:e,maxDimension:n}){const a={rawShape:[0,0],count:0,dimension:0,vectors:new Float32Array,labels:[],metadata:[]};r&&(Object.assign(a,R(r)),Object.assign(a,D(t,a.count)));const o=w(a,e,n),{metadata:c}=o,s=M(o,["metadata"]);return l(l({},s),{},{metadata:P(c)})}export async function parseFromBlob({shape:r,vectors:t,metadata:e,maxCount:n,maxDimension:a}){const[o,c]=r,s=new Float32Array(await t.arrayBuffer());if(o*c!==s.length)throw new ParserError("Size of tensor does not match.",ParserError.CODES.SHAPE_MISMATCH);const i=w(l({rawShape:r,count:o,dimension:c,vectors:s},D(e,o)),n,a),{metadata:m}=i,h=M(i,["metadata"]);return l(l({},h),{},{metadata:P(m)})}
